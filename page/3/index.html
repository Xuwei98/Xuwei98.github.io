<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="偽のブログ" type="application/atom+xml">






<meta name="description" content="圈地自萌,自娱自乐">
<meta property="og:type" content="website">
<meta property="og:title" content="偽のブログ">
<meta property="og:url" content="http://xwdidi.com/page/3/index.html">
<meta property="og:site_name" content="偽のブログ">
<meta property="og:description" content="圈地自萌,自娱自乐">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="偽のブログ">
<meta name="twitter:description" content="圈地自萌,自娱自乐">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Xuwei98'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://xwdidi.com/page/3/">





  <title>偽のブログ</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">偽のブログ</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xwdidi.com/2018/10/04/2018-10-04-L19死锁处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xuwei98">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="偽のブログ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/04/2018-10-04-L19死锁处理/" itemprop="url">进程与线程  死锁处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-04T00:00:00+08:00">
                2018-10-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/04/2018-10-04-L19死锁处理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/10/04/2018-10-04-L19死锁处理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  778
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>多进程同时触发交替执行,会出现互相死锁的情况.</p>
<h2 id="本文重点"><a href="#本文重点" class="headerlink" title="本文重点"></a>本文重点</h2><p>生产者-消费者的信号量解法</p>
<p>死锁形成了环路等待,推进自己的条件是需要自己向前推进</p>
<p>我们将这种多个进程由于互相等待对方持有的资源而造成的谁都无法执行的情况叫<strong>死锁</strong></p>
<p>死锁造成了资源锁定,被阻塞的进程越来越多,CPU无资源运行</p>
<h4 id="死锁的成因"><a href="#死锁的成因" class="headerlink" title="死锁的成因"></a>死锁的成因</h4><ul>
<li>资源互斥使用,一旦占有别人无法使用</li>
<li>进程占有了一些资源，又不释放，再去申请其他资源</li>
<li>各自占有的资源和互相申请的资源形成了环路等待</li>
</ul>
<h4 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h4><ul>
<li><p>固有特性</p>
<ul>
<li>互斥使用</li>
<li>不可抢占</li>
</ul>
</li>
<li>请求和保持，必须占有资源，再去申请</li>
<li>循环等待，资源分配存在环路</li>
</ul>
<h4 id="如何处理死锁"><a href="#如何处理死锁" class="headerlink" title="如何处理死锁"></a>如何处理死锁</h4><ol>
<li><p>死锁预防 </p>
<ul>
<li><p>破坏思索条件</p>
</li>
<li><p>只要不形成环路，就不会有环路</p>
</li>
<li>只要不占有资源，就不会死锁</li>
</ul>
<p><em>不占有资源，一次性申请所有资源，不会占有资源是再去申请资源。</em></p>
<ul>
<li>编程困难，不容易预支未来</li>
<li>资源份额皮厚很长时间后才使用，资源利用率低</li>
</ul>
<p><em>对资源类型进行排序，资源申请必须按序进行，不会出现环路等待</em></p>
<ul>
<li>浪费资源，只有预定好前面资源，不能中途释放他，</li>
</ul>
</li>
<li><p>死锁避免</p>
<ul>
<li>检测每个资源请求，如果造成死锁就拒绝。</li>
</ul>
<p>判断进程存在一个可完成的执行序列。则这时候系统处于安全状态</p>
<p><img src="https://i.loli.net/2018/10/04/5bb624efd3e96.jpg" alt></p>
<p>先执行p1,可分配变量增大为532 然后在执行p3,然后变成743,然后….选择A</p>
<p>由此引出了 一个算法 </p>
<ul>
<li><p>银行家算法</p>
<p><img src="https://i.loli.net/2018/10/04/5bb626be84f0c.jpg" alt></p>
<p>判断资源是否小于work,然后执行,然后返回资源.</p>
<p>时间复杂度较高T(n)=O(mn^2);</p>
<p>请求时:首先首先假装分配,然后调用银行家算法判断是否可行. 而不是请求后直接分配,这样也会造成死锁</p>
</li>
</ul>
</li>
<li><p>死锁检测+恢复:发现问题再处理</p>
<ul>
<li>检测到死锁出现时，让一些进程回滚，让出资源</li>
</ul>
<p>每次执行银行家算法会造成效率低下,发现问题时再处理</p>
<ul>
<li><p>定时检测或者是发现资源利用率低时检测</p>
<p><img src="https://i.loli.net/2018/10/04/5bb62914d14bf.jpg" alt></p>
</li>
</ul>
</li>
</ol>
<pre><code>然而采用进程会滚的话,会涉及到很多已处理的操作,如何实现回复呢,如何选择那些进程回滚呢,优先级又怎么设定了,所以看下面,.
</code></pre><ol start="4">
<li><p>死锁忽略</p>
<ul>
<li><p>死锁出现是不确定得.发生死锁后，可以重启来处理死锁，</p>
<p>Linux和windows都采用了死锁忽略的方法,优点在于</p>
<ul>
<li>.死锁忽略的处理代价最小    </li>
<li>这种机器上出现死锁的概率比其他机器低</li>
<li>死锁可以用重启来解决，PC重启造成的影响小</li>
<li>死锁预防让编程变得困难</li>
</ul>
</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xwdidi.com/2018/10/03/2018-10-03-熟悉IDA,以及手工制作sig文件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xuwei98">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="偽のブログ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/03/2018-10-03-熟悉IDA,以及手工制作sig文件/" itemprop="url">熟悉IDA,以及手工制作sig文件.</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-03T00:00:00+08:00">
                2018-10-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IDA/" itemprop="url" rel="index">
                    <span itemprop="name">IDA</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/03/2018-10-03-熟悉IDA,以及手工制作sig文件/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/10/03/2018-10-03-熟悉IDA,以及手工制作sig文件/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  666
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第一步-打包制作lib"><a href="#第一步-打包制作lib" class="headerlink" title="第一步 打包制作lib"></a>第一步 打包制作lib</h3><p>obj是.c文件编译后的格式</p>
<p>因为vs下工具的不熟悉,网上查的指令无法实现</p>
<p>暂时使用g++带的打包工具打包,若以后得知会进行补充</p>
<p>命令为 ar cr libc.lib  main.o 生成了名为libc的库</p>
<blockquote>
<p>打包(archive)，于是就成为了传说中的库文件(library)。在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。</p>
</blockquote>
<p>放入ida中可看到</p>
<p><img src="https://i.loli.net/2018/10/03/5bb4e03a8bc75.jpg" alt></p>
<h3 id="使用pcf-exe-特征提取工具"><a href="#使用pcf-exe-特征提取工具" class="headerlink" title="使用pcf.exe(特征提取工具)"></a>使用pcf.exe(特征提取工具)</h3><p>在flair工具包里</p>
<p>命令为 <code>pcf main.o</code></p>
<p>得到main.pat</p>
<p><img src="https://i.loli.net/2018/10/03/5bb4e1ef04f71.jpg" alt></p>
<p>特征码内部结构.2E2E2E什么的应该做补充.感觉ascii也能感觉大概是什么</p>
<h3 id="生成-sig文件"><a href="#生成-sig文件" class="headerlink" title="生成.sig文件"></a>生成.sig文件</h3><p>命令 <code>sigmake main.pat main.sig</code></p>
<p>出现错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">;--------- (delete these lines to allow sigmake to read this file)</span><br><span class="line">; add &apos;+&apos; at the start of a line to select a module</span><br><span class="line">; add &apos;-&apos; if you are not sure about the selection</span><br><span class="line">; do nothing if you want to exclude all modules</span><br><span class="line"></span><br><span class="line">?y@Point@@UEBAMXZ                                 	00 0000 48894C24080F57C0C3..............................................</span><br><span class="line">?z@Point@@UEBAMXZ                                 	00 0000 48894C24080F57C0C3..............................................</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.删除上面4行以分号开头的注释 </span><br><span class="line">2.sigmake让你仅指定一个函数作为相关签名的匹配函数。任何时候，如果在数据库中发现一个对应的签名，并且你想应用一个函数的名称，那么，你可以在该函数名称前附加一个加号；如果你只想在数据库中添加某个函数的注释，则在该函数名称前附加一个减号；如果在数据库中发现对应的签名时，你不想应用任何名称，那么，你不需要添加任何符号。（+号只能有一个，-号和+号二者只能存一） </span><br><span class="line"></span><br><span class="line">（1）为最大限度地减少冲突，请删除排斥文件开头的4个注释行。 </span><br><span class="line">  （2）最多只能给冲突函数组中的一个函数附加+/-。 </span><br><span class="line">  （3）如果一个冲突函数组仅包含一个函数，不要在该函数前附加+/-，让它保持原状即可。 </span><br><span class="line">  （4）sigmake连续运行失败会将数据（包括注释行）附加到现有的任何.exc文件后。在再次运行sigmake之前，你必须删除这些额外的数据，并更正原始数据（如果这些数据是正确的，sigmake将不会再次运行失败）。</span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line"></span><br><span class="line">本文来自 花熊 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/hgy413/article/details/50612296?utm_source=copy</span><br></pre></td></tr></table></figure>
<p>然后再次执行相同命令 生成sig文件</p>
<p>放入到ida的sig目录下 通过shift+f5导入sig文件就能实现对机器码的转换</p>
<blockquote>
<p><a href="https://blog.csdn.net/gyh198/article/details/7028530" target="_blank" rel="noopener">https://blog.csdn.net/gyh198/article/details/7028530</a> 工具说明</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xwdidi.com/2018/10/02/2018-10-02-L18信号量的代码实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xuwei98">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="偽のブログ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/02/2018-10-02-L18信号量的代码实现/" itemprop="url">进程与线程   L18 信号量的代码实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-02T00:00:00+08:00">
                2018-10-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/02/2018-10-02-L18信号量的代码实现/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/10/02/2018-10-02-L18信号量的代码实现/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  796
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前文回顾"><a href="#前文回顾" class="headerlink" title="前文回顾"></a>前文回顾</h2><p>如何实现进程间的同步, 信号量又是什么. 使用临界区保护信号量.</p>
<h2 id="重点总结"><a href="#重点总结" class="headerlink" title="重点总结"></a>重点总结</h2><p>需要进行磁盘读写时,会进行很多判断,是否能写入,中断执行等等 都是类似与进程同步使用信号量的原理</p>
<p>通过这部分代码实现,提高对信号量的认识,在操作系统内部要增加多个执行序列的同步,这样才能合理有序的向前执行.</p>
<h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Producer(item)&#123;</span><br><span class="line">	P(empty);</span><br><span class="line">		...</span><br><span class="line">	V(full);&#125;</span><br></pre></td></tr></table></figure>
<p>用户态程序(producer.c)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">(<span class="number">1</span>)sd=sem_open(<span class="string">"empty"</span>);	<span class="comment">//在内核中打开名为empty的信号量</span></span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)<span class="keyword">for</span>(i=<span class="number">1</span> to <span class="number">5</span>)</span><br><span class="line">    sem_wait(sd);		</span><br><span class="line">	write(fd,&amp;i,<span class="number">4</span>);			<span class="comment">//在文件里 一次写入这五个数</span></span><br></pre></td></tr></table></figure>
<p>sem.c</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入内核</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];		<span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    task_struct *<span class="built_in">queue</span>;</span><br><span class="line">&#125;semtable[<span class="number">20</span>];</span><br><span class="line">sys_sem_open(<span class="keyword">char</span> * name)&#123;</span><br><span class="line">    在semtable中寻找name对上的;</span><br><span class="line">    没找到则创建;</span><br><span class="line">    返回对应的下标;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="sys-sem-wait如何工作"><a href="#sys-sem-wait如何工作" class="headerlink" title="sys_sem_wait如何工作"></a>sys_sem_wait如何工作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sys_sem_wait(<span class="keyword">int</span> sd)&#123;</span><br><span class="line">    cli();							<span class="comment">//使用开关中断进行信号量保护</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>（semtable[sd].value--&lt;<span class="number">0</span>）&#123;		<span class="comment">//根绝传入的sd,找到信号量的值,小于0则会阻塞,</span></span><br><span class="line">        </span><br><span class="line">    设置自己为阻塞;</span><br><span class="line">    将自己加入semtable[sd].<span class="built_in">queue</span>中;</span><br><span class="line">    schedule();</span><br><span class="line">    &#125;</span><br><span class="line">	sti();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//v操作,从阻塞态队列取出放入到就绪态,empty++</span></span><br></pre></td></tr></table></figure>
<h4 id="读磁盘"><a href="#读磁盘" class="headerlink" title="读磁盘"></a>读磁盘</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bread(<span class="keyword">int</span> dev,<span class="keyword">int</span> block)&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> <span class="title">head</span> * <span class="title">bh</span>;</span>		<span class="comment">//申请空闲缓冲区</span></span><br><span class="line">    </span><br><span class="line">	<span class="number">11</span>_rw_block(READ,bh); 			<span class="comment">//启动读取命令</span></span><br><span class="line">    </span><br><span class="line">    wait_on_buffer(bh);		 <span class="comment">//阻塞</span></span><br></pre></td></tr></table></figure>
<p>读磁盘块时,申请内存缓冲区,采用DMA将磁盘块读入. 通过中断来保护临界区</p>
<p>启动磁盘读以后睡眠,等待磁盘读完磁盘中断将其唤醒,也是一种同步</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lock_buffer(buffer_head*bh)&#123;</span><br><span class="line">    cli();					<span class="comment">//开关中断 保护信号量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(bh-&gt;b_lock)???</span><br><span class="line">    	sleep_on(&amp;bh-&gt;b_wait);		<span class="comment">//判断信号量,判断是否睡眠	</span></span><br><span class="line">    </span><br><span class="line">    bh-&gt;b_lock = <span class="number">1</span>;</span><br><span class="line">    sti();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="sleep-on代码解析"><a href="#sleep-on代码解析" class="headerlink" title="sleep_on代码解析"></a>sleep_on代码解析</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep_on</span><span class="params">(struct task_struct **p)</span></span>&#123;			<span class="comment">//传递的是指向task_struct结构的指针的指针</span></span><br><span class="line">    </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span>			<span class="comment">//tmp放在当前进程的内核栈里</span></span><br><span class="line">    </span><br><span class="line">	tmp=*p;				<span class="comment">//放在就绪队列中</span></span><br><span class="line">    </span><br><span class="line">	*p=current; </span><br><span class="line">	current-&gt;state=TASK_UNINTERRUPTIBLE;  <span class="comment">//状态变为阻塞态</span></span><br><span class="line">    </span><br><span class="line">	schedule(); </span><br><span class="line">	<span class="keyword">if</span>(tmp)</span><br><span class="line">		tmp-&gt;state=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2018/10/02/5bb350d25db99.jpg" alt></p>
<p>tmp是指向原来的task_struct,而*p指向了current的task_struct,指向了新的阻塞队列队首</p>
<p>根据task_struct能找到内核栈就能找到tmp,tmp指向了下个进程的PCB,就形成了队列.队首一直是**p.</p>
<h3 id="如何从Linux0-11的这个队列中唤醒"><a href="#如何从Linux0-11的这个队列中唤醒" class="headerlink" title="如何从Linux0.11的这个队列中唤醒"></a>如何从Linux0.11的这个队列中唤醒</h3><p> <img src="https://i.loli.net/2018/10/02/5bb3531533ff5.jpg" alt></p>
<p>将b_lock置为0,将**p中的state=0,将状态变为0,就变为了就绪态,唤醒队首的元素.</p>
<p>然后执行右上角的sleep_on的最后三句,schedule(); 判断tmp,tmp是指向了队列中下一个进程.将tmp的PCB再唤醒.将阻塞队列中全部唤醒的机制. 所以前文中的while是全部唤醒,而if只是唤醒队首元素.</p>
<p>为什么要唤醒所有的呢,如果if的话总是第一个优先执行,然而如果全部唤醒的话,会再次判断使优先级更高的先执行,而不是因为优先级高的晚进入队列,被拖延执行.</p>
<p>while(lock)不会存在负数,不用记住有多少进程正在等待.优先级高的进程</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xwdidi.com/2018/10/01/2018-10-01-L17信号量临界区保护/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xuwei98">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="偽のブログ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/01/2018-10-01-L17信号量临界区保护/" itemprop="url">进程与线程  L17 信号量临界区保护</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-01T00:00:00+08:00">
                2018-10-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/01/2018-10-01-L17信号量临界区保护/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/10/01/2018-10-01-L17信号量临界区保护/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="铺垫"><a href="#铺垫" class="headerlink" title="铺垫"></a>铺垫</h2><p>没有保护,信号量是不能工作的.</p>
<ol>
<li>靠临界区保护信号量</li>
<li>靠信号量实现同步</li>
</ol>
<ul>
<li>为什么要保护信号量,为什么要引入临界区的概念</li>
<li>实际中保护信号量,如何实现临界区</li>
</ul>
<h2 id="重点总结"><a href="#重点总结" class="headerlink" title="重点总结"></a>重点总结</h2><h4 id="什么是信号量"><a href="#什么是信号量" class="headerlink" title="什么是信号量"></a>什么是信号量</h4><p>是一个整形变量,让多个进程有序推进.,就像上一节的empty一样,如果存在empty = -1,说明有由生产者在sleep,需要被唤醒.</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>整个程序只能通过empty这个信号量推进,只有保证empty有正确的值,才能保证进程间的正确合作.</p>
<p>如果生产者和消费者,同时修改empty变量,会造成empty的值错误.这是进程间很容易出现的问题.<strong>由于竞争条件造成和调度有关的共享数据语义错误.</strong></p>
<p><strong>错误由多个进程并发操作共享数据引起错误和调度顺序有关，难于发现和调试</strong></p>
<h4 id="解决竞争条件的直观想法"><a href="#解决竞争条件的直观想法" class="headerlink" title="解决竞争条件的直观想法"></a>解决竞争条件的直观想法</h4><p>在写共享变量empty时组织其他进程访问empty</p>
<ol>
<li><p>P1 检查并给empty上锁</p>
</li>
<li><p>P2 检查empty的锁</p>
</li>
<li><p>P2 给empty开锁</p>
</li>
<li><p>P2 检查并给empty上锁</p>
</li>
</ol>
<p>一段代码一次只允许一个进程进入.<strong>原子操作</strong></p>
<h3 id="临界区-Critical-Section"><a href="#临界区-Critical-Section" class="headerlink" title="临界区(Critical Section)"></a>临界区(Critical Section)</h3><p>一次只允许一个进程进入的该进程的那一段代码.</p>
<p>一个进程进去修改修改信号量时,别的进程决不能进去修改同一信号量.读写信号量的代码一定是临界区<img src="https://i.loli.net/2018/10/01/5bb210d590aff.jpg" alt></p>
<blockquote>
<p>修改信号量的代码一定是在临界区,需要保护</p>
</blockquote>
<h4 id="如何保护"><a href="#如何保护" class="headerlink" title="如何保护"></a>如何保护</h4><p>如何进入,如何退出.</p>
<ol>
<li><p>基本原则:互斥进入,如果一个进程在临界区中执行,则其他进程不允许进入</p>
<ul>
<li>a这些进程间的约束关系称为互斥（mutual exclusion）</li>
<li>这保证了是临界区</li>
</ul>
</li>
<li><p>好的临界区保护原则</p>
<ul>
<li>有空让进：若干进程要求进入空闲临界区时，应尽快使一进程进入临界区</li>
<li>有限等待：从进程发出进入请求到允许进入，不能无限等待</li>
</ul>
</li>
</ol>
<ul>
<li><p>第一个尝试:轮换法</p>
<p><img src="https://i.loli.net/2018/10/01/5bb213298b307.jpg" alt></p>
<p>满足互斥进入要求.但是不满足有空让进. 如果二者都没在临界区,即使turn赋值,也不执行</p>
</li>
<li><p>第二个尝试</p>
<p>轮换法类似于值日. 通过增加一个标记,判断程序是否在临界区执行.</p>
<p><img src="https://i.loli.net/2018/10/01/5bb21753542c4.jpg" alt></p>
</li>
</ul>
<p>满足互斥原则,如果flag中两者都为true,二者都会自循,二者没人进入临界区,此时Po和P1的进入<br>请求会无限等待. </p>
<ul>
<li><p>第三个尝试</p>
<p>非对称标记,让另一个”人”更勤劳</p>
</li>
</ul>
<h3 id="进入临界区Peterson算法"><a href="#进入临界区Peterson算法" class="headerlink" title="进入临界区Peterson算法"></a>进入临界区Peterson算法</h3><p>  <img src="https://i.loli.net/2018/10/01/5bb21a27bf4eb.jpg" alt></p>
<p>  结合值日+标记的方法.</p>
<ul>
<li>满足互斥进入,lag[0]=flag[1]=true，urn==0==1，矛盾！</li>
<li>满足有空让进,如果进程P1不在临界区，则flag[1]=false，或者turn=0，都P0能进入！</li>
<li>满足有限等待,Po要求进入，flag[0]=true；后面的P1不可能一直进入，因为P1执行一次就会让turn=0。</li>
</ul>
<h4 id="多个进程呢"><a href="#多个进程呢" class="headerlink" title="多个进程呢?"></a>多个进程呢?</h4><ol>
<li>面包店算法(软件方法),仍然是标记和轮转的结合.</li>
</ol>
<ul>
<li><p>如何轮转,每个进程都获得一个序号,序号最小的进入</p>
</li>
<li><p>如何标记,进程离开时序号为0,不为0即标记</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进程Pi</span></span><br><span class="line"></span><br><span class="line">choosing[i]=<span class="literal">true</span>; num[i]=max(num[<span class="number">0</span>],..., num[n<span class="number">-1</span>])+<span class="number">1</span>;</span><br><span class="line">choosing[i]=<span class="literal">false</span>; </span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123; </span><br><span class="line">    <span class="keyword">while</span>(choosing[i]); </span><br><span class="line">    <span class="keyword">while</span>((num[i]!=<span class="number">0</span>)&amp;&amp;(num[j],j)&lt;(num[i],i]));</span><br><span class="line">&#125;</span><br><span class="line">临界区</span><br><span class="line">num[i] = <span class="number">0</span>;</span><br><span class="line">剩余区</span><br></pre></td></tr></table></figure>
<p>先取号,让号码最小的先进入临界区,号码相同时,名字靠前的先执行.</p>
<p>等大家都选完号之后,再进行判断是否进入临界区执行.</p>
<ul>
<li>互斥进入:P，在临界区内，P试图进入，一定有(num[i],i)&lt;(num[k],k)，Pk循环等待。</li>
<li>有空让进：如果没有进程在临界区中，最小序号的进程一定能够进入。</li>
<li>有限等待：离开临界区的进程再次进入一定排在最后（FIFO），所以任一个想进入进程至多等n个进程</li>
</ul>
</li>
</ul>
<p>过于复杂,如何简化</p>
<ol start="2">
<li><p>(硬件方法),软硬协同设计</p>
<p>只允许一个进程进入,进入另一进程意味什么.</p>
<ol>
<li>应该是进程的调度,如果阻止了中断就无法进行调度操作.(开关中断)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进程pi</span></span><br><span class="line"></span><br><span class="line">cli();</span><br><span class="line">	临界区</span><br><span class="line">sti();</span><br><span class="line">	剩余区</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>cli();</code>关闭中断.然而在多CPU时不好用. 中断</p>
<p>中断寄存器INTR,每次执行中断,INTR置为1,而Cli()指令会忽视INTR.</p>
<p>多CPU的话,有多个INTR,程序中的cli()无法控制其他CPU的中断.</p>
<p>实现5鼓励使用这种方法.</p>
</li>
</ul>
</li>
<li><p>硬件原子指令法</p>
<p>上锁,执行完,开锁.</p>
<p>就像之前所说的mutex,通过查询mutex的值判断是否上锁.mutex不应该由用户态保护,因为这样的话,保护的信号量无穷无尽.而使用硬件保护,不能被打断(原子指令).</p>
<p>使用硬件原子指令修改变量,再判断是否能进入,原子指令无法被打断会一直执行到完毕</p>
<p><strong>其中一种原子指令.</strong></p>
<p><img src="https://i.loli.net/2018/10/01/5bb222d7a3ce7.jpg" alt></p>
<p>如果被锁上 返回值为rv,tv为真. </p>
<p>进程Pi进行判断,会进行空转.</p>
<p>如果没锁上就能进入临界区.</p>
<ul>
<li>满足互斥进入,lock锁上后,进程无法进入  </li>
</ul>
</li>
</ol>
<pre><code>多CPU中,使用原子操作的话,会锁住总线,防止在&quot;读取, 修改, 写入&quot;整个过程期间其他CPU访问内存.
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>需要用临界区保护信号量,可以用上述三种方法保护信号量,信号量语意正确.根据语意实现进程的同步,有序合理推进.</p>
<blockquote>
<p>用临界区保护信号量</p>
<p>用信号量实现进程同步</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xwdidi.com/2018/09/30/2018-09-30-L16进程同步与信号量/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xuwei98">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="偽のブログ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/30/2018-09-30-L16进程同步与信号量/" itemprop="url">进程与线程   L16 进程的同步与信号量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-30T00:00:00+08:00">
                2018-09-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/30/2018-09-30-L16进程同步与信号量/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/09/30/2018-09-30-L16进程同步与信号量/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  836
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>实现多进程图像,切换,多个进程在内存中进行合作</p>
<p>为了使进程同步,合理有序,</p>
<p>如何依靠信号量实现同步?</p>
<h2 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h2><h3 id="多进程共同完成一个任务"><a href="#多进程共同完成一个任务" class="headerlink" title="多进程共同完成一个任务"></a>多进程共同完成一个任务</h3><p>不同的进程在共用同一片内存中,如果不进行约束,会造成冲突崩溃.</p>
<p>每个进程执行有自己的执行方案,有时候需要停下来等待,需要通过某些信号继续执行, 引出了信号量的概念.</p>
<h3 id="生产者-消费者实例"><a href="#生产者-消费者实例" class="headerlink" title="生产者 消费者实例"></a>生产者 消费者实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>...&#125;item;</span><br><span class="line">item buffer[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">int</span> in = out = counter=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//共享数据</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(counter==BUFFER_SIZE) </span><br><span class="line">        sleep();</span><br><span class="line">    buffer[in]=item; </span><br><span class="line">    in=(in +<span class="number">1</span>)% BUFFER_SIZE; </span><br><span class="line">    counter++;</span><br><span class="line">    <span class="keyword">if</span>(counter == <span class="number">1</span>)</span><br><span class="line">        wakeup(消费者);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产者进程</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="keyword">while</span>(counter==<span class="number">0</span>)</span><br><span class="line">		sleep();</span><br><span class="line">item=buffer[out]; </span><br><span class="line">out=(out +<span class="number">1</span>)% BUFFER_SIZE </span><br><span class="line">counter--;</span><br><span class="line"><span class="keyword">if</span>(counter==BUFFER_SIZE<span class="number">-1</span>)</span><br><span class="line">    wakeup(生产者);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者进程</span></span><br></pre></td></tr></table></figure>
<p>为了正确合作完成任务,进程要学会等待,阻塞.  </p>
<p>进程走走停停,保证进程合作的合理有序,这就是 进程同步</p>
<p>以实例来说,缓存区慢,生产者要停, 发信号让消费者再走. 缓冲区空,消费者要停,发信号让生产者再运行.</p>
<p>如果存在两个生产者,就会造成单一生产者和消费者互动,第二个生产者无法被唤醒.</p>
<p>counter作为标识符不足以满足进程合作的需求了,应该增加一个变量.来判断是否应该发送信号,这个量就叫做信号量</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><ul>
<li><p>不止是等待信号发信号,对应睡眠和唤醒.</p>
</li>
<li><p>记录相关进程的数量.</p>
<ul>
<li><p>信号不足以反馈状态.</p>
<ol>
<li>缓冲区满了,需要记录进程数量,可以记为sem = -1,</li>
<li>P2sleep, sem = -2,</li>
<li>消费者执行循环,信号量这时候为-2,需要去唤醒阻塞队列中的第一位,此时sem=-1.</li>
<li>再执行一次循环,唤醒阻塞队列中的第一位,sem = 0;</li>
<li>再次执行循环 sem = 1,此时表示了还有一个空闲缓冲区.</li>
<li>第三个生产者顺利执行.</li>
</ol>
<p>为了处理复杂的情况,用信号量存取更丰富的内容.可以根据信号量等待唤醒其他进程了.根据信号量的值决定了等待 ,执行</p>
<h4 id="信号量的定义"><a href="#信号量的定义" class="headerlink" title="信号量的定义"></a>信号量的定义</h4></li>
</ul>
</li>
</ul>
<p>信号量：1965年，由荷兰学者Dijkstra提出的一种特殊整型变量，量用来记录，信号用来sleep和wakeup</p>
<p><img src="https://i.loli.net/2018/09/30/5bb0d98e17f26.png" alt></p>
<p> P(sem)是申请资源的方式, 这个结构体也关联了一个阻塞队列.如果value小于0,会进行阻塞.</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v(semaphore s)</span><br><span class="line">&#123;</span><br><span class="line">    s.value++;</span><br><span class="line">    <span class="keyword">if</span>(value &lt;=  <span class="number">0</span>)</span><br><span class="line">    	wakeup(s.<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> p v两者调用都做成内核态,做成系统调用.</p>
<p>P的名称来源于荷兰语的proberen，即test ,检查<br>V的名称也来源于荷兰语verhogen（increment）,增加</p>
<h4 id="利用信号量解决生产者消费者问题"><a href="#利用信号量解决生产者消费者问题" class="headerlink" title="利用信号量解决生产者消费者问题"></a>利用信号量解决生产者消费者问题</h4><p><img src="https://i.loli.net/2018/09/30/5bb0e0772826a.png" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Producer(item)&#123;</span><br><span class="line">	P(empty);	<span class="comment">//使用空闲缓冲区个数</span></span><br><span class="line">    </span><br><span class="line">	P(mutex）</span><br><span class="line">	读入in；将item写入到in的位置上;</span><br><span class="line">	V(mutex);			<span class="comment">//mutex为互斥量,对文件的读写也就是缓冲区进行保护</span></span><br><span class="line">      </span><br><span class="line">	V(full);		<span class="comment">//增加</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Consumer()&#123;</span><br><span class="line">	P(full);		<span class="comment">//full表示了生产了多少个东西</span></span><br><span class="line">    </span><br><span class="line">	P(mutex);</span><br><span class="line">	读入out;从文件中的out位置读出到item;打印item;</span><br><span class="line">	V(mutex);</span><br><span class="line">	V(empty);		<span class="comment">//增加空闲缓冲区个数</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xwdidi.com/2018/09/29/2018-09-29-L15一个实际的schedule函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xuwei98">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="偽のブログ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/29/2018-09-29-L15一个实际的schedule函数/" itemprop="url">进程与线程     L15 一个实际的schedule函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-29T00:00:00+08:00">
                2018-09-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/29/2018-09-29-L15一个实际的schedule函数/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/09/29/2018-09-29-L15一个实际的schedule函数/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  651
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前文回顾"><a href="#前文回顾" class="headerlink" title="前文回顾"></a>前文回顾</h3><ul>
<li>io约束型 cpu约束型</li>
<li>周转时间 响应时间的抉择</li>
<li>调度因素过多,如何相互权衡</li>
</ul>
<h3 id="课程重点"><a href="#课程重点" class="headerlink" title="课程重点"></a>课程重点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,next,c;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> ** <span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        c = <span class="number">-1</span>;</span><br><span class="line">        next = <span class="number">0</span>;</span><br><span class="line">        i = NR_TASKS;</span><br><span class="line">        p = &amp;task[NR_TASKS];	<span class="comment">//PCB做成数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (--i) &#123;			<span class="comment">//从末尾往前移动</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!*--p)</span><br><span class="line">                <span class="keyword">continue</span>;		</span><br><span class="line">            <span class="keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)	<span class="comment">//就绪队列,counter大于c</span></span><br><span class="line">                </span><br><span class="line">                c = (*p)-&gt;counter, next = i;			</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c) <span class="keyword">break</span>;	<span class="comment">//找到最大的counter</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line">            <span class="keyword">if</span> (*p)</span><br><span class="line">                (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) +</span><br><span class="line">                (*p)-&gt;priority; <span class="comment">//counter的初值,阻塞态的值一定大于就绪态</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    switch_to(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用counter 时间片进行优先级调度,又基于时间用来做轮转调度,维护简单</p>
<p>就绪态任务的counter值都为0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_timer</span><span class="params">(<span class="keyword">long</span> cpl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">int</span> beepcount;</span><br><span class="line">	<span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">sysbeepstop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (beepcount)</span><br><span class="line">		<span class="keyword">if</span> (!--beepcount)</span><br><span class="line">			sysbeepstop();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cpl)</span><br><span class="line">		current-&gt;utime++;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		current-&gt;stime++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (next_timer) &#123;</span><br><span class="line">		next_timer-&gt;jiffies--;</span><br><span class="line">		<span class="keyword">while</span> (next_timer &amp;&amp; next_timer-&gt;jiffies &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">void</span> (*fn)(<span class="keyword">void</span>);</span><br><span class="line">			</span><br><span class="line">			fn = next_timer-&gt;fn;</span><br><span class="line">			next_timer-&gt;fn = <span class="literal">NULL</span>;</span><br><span class="line">			next_timer = next_timer-&gt;next;</span><br><span class="line">			(fn)();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (current_DOR &amp; <span class="number">0xf0</span>)</span><br><span class="line">		do_floppy_timer();</span><br><span class="line">	<span class="keyword">if</span> ((--current-&gt;counter)&gt;<span class="number">0</span>) <span class="keyword">return</span>; 	<span class="comment">//减一,如果conter为0 发生调度</span></span><br><span class="line">    </span><br><span class="line">	current-&gt;counter=<span class="number">0</span>;		</span><br><span class="line">	<span class="keyword">if</span> (!cpl) <span class="keyword">return</span>;</span><br><span class="line">	schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timer_interrupt:</span><br><span class="line">...</span><br><span class="line">call do_timer		# &apos;do_timer(long CPL)&apos; does everything from</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">	set_intr_gate(<span class="number">0x20</span>,&amp;timer_interrupt);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>counter承担时间片的作用,轮转调度,保证了响应</p>
<p>也承担了优先级的作用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)	<span class="comment">//就绪队列,counter大于c</span></span><br><span class="line">    </span><br><span class="line">c = (*p)-&gt;counter, next = i;	</span><br><span class="line">---------</span><br><span class="line"><span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)&#123;</span><br><span class="line">	<span class="keyword">if</span> (*p)</span><br><span class="line">		(*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) +		<span class="comment">//找到counter最大的任务调度 表示优先级</span></span><br><span class="line">        </span><br><span class="line">		(*p)-&gt;priority; &#125;</span><br></pre></td></tr></table></figure>
<p>进行了动态调整,I\O的counter越大,优先级更高. I\O约束型进程正是前台程序的特征.</p>
<h4 id="counter的作用"><a href="#counter的作用" class="headerlink" title="counter的作用"></a>counter的作用</h4><ul>
<li><p>counter保证了响应时间的界</p>
<p>如果初值为p,一直阻塞的话,counter无限增加,变为最长时间片c(t) = c(t-1)/2 + p</p>
<p>c1 = 3/2P c2 = 7/4P ………. 越来越大  ,是收敛的,一直向2P靠近</p>
<p>c(t) &lt;= 2P  周转时间最多为2nP</p>
</li>
<li><p>经过IO以后，counter就会变大；IO时间越长，counter越大（为什么？），照顾了I/0进程，变相的照顾了前台进程</p>
</li>
<li><p>轮转调度保证了响应时间,I\O时间片长,优先级高,照顾了前台进程,</p>
</li>
<li><p>后台进程按照时间片轮转,近似了SJF.造成短作业进程先完成.</p>
</li>
<li><p>每个进程只用维护一个counter变量，简单、高效</p>
</li>
</ul>
<blockquote>
<p>CPU调度：一个简单的算法折中了大多数任务的需求，这就是实际工作的schedule函数</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xwdidi.com/2018/09/28/2018-09-28-L14CPU调度策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xuwei98">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="偽のブログ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/28/2018-09-28-L14CPU调度策略/" itemprop="url">进程与线程 L14 CPU调度策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-28T00:00:00+08:00">
                2018-09-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/28/2018-09-28-L14CPU调度策略/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/09/28/2018-09-28-L14CPU调度策略/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  562
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h2><h3 id="CPU调度的直观想法"><a href="#CPU调度的直观想法" class="headerlink" title="CPU调度的直观想法"></a>CPU调度的直观想法</h3><h4 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h4><p>对于简单操作的程序并不是很合适</p>
<ul>
<li><p>优先级</p>
<p>任务短可以优先,然而会出现意外状况执行时间加长</p>
</li>
</ul>
<h4 id="更好的算法"><a href="#更好的算法" class="headerlink" title="更好的算法"></a>更好的算法</h4><p>为了让进程满意执行,</p>
<ul>
<li>尽快结束任务:周转时间短</li>
<li>用户操作尽快响应:响应时间短</li>
<li>系统内耗时间少:吞吐量</li>
</ul>
<p>专注任务执行,又能合理调配任务 </p>
<h4 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h4><ul>
<li><p>吞吐量与响应时间 响应时间小&gt;切换次数多&gt;系统内耗大&gt;吞吐量小</p>
</li>
<li><p>前台任务(响应时间)与后台任务(周转时间) </p>
</li>
<li><p>I|O约束型 与 计算约束型任务</p>
<p><img src="https://i.loli.net/2018/09/28/5bae2ea61982e.png" alt></p>
</li>
<li><p>I|O约束型优先级较高,因为能快速阻塞,然后执行其他任务</p>
</li>
<li>折中的综合让操作系统变得复杂,有效的系统又要求简单</li>
</ul>
<h4 id="基本调度算法"><a href="#基本调度算法" class="headerlink" title="基本调度算法"></a>基本调度算法</h4><ol>
<li><p>First Come First Served(FCFS)</p>
</li>
<li><p>SJF:短作业优先 周转时间最小 t = ∑(n+1-i)Pi</p>
</li>
<li><p>响应时间问题,通过时间片轮转调度.(RoundRobin)能够保证响应时间</p>
<p><img src="https://i.loli.net/2018/09/28/5bae3642ef01e.png" alt></p>
<p>时间片大响应时间长;时间片小吞吐量不够. 选择10-100ms的时间片,切换时间为0.l-1ms之间</p>
</li>
<li><p>响应时间与周转时间的抉择 优先级的选择</p>
<p>直观想法:定义前台任务和后台任务两队列，前台RR，后台SJF，只有前台任务没有时才调度后台任务</p>
<p><img src="https://i.loli.net/2018/09/28/5bae383ae2020.png" alt></p>
<p>存在执行的可能性,</p>
<p>然而前台任务一直存在,后台任务无法执行.</p>
<p>所以产生除了后台任务优先级动态升高,但后台任务一旦执行.前台又怎么办呢 如何兼顾两者</p>
<p>将所有任务都用时间片,sjf怎么去实现呢前台任务怎么呢</p>
<p>以rr为核心,sjf为重点</p>
<h3 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h3><ul>
<li>我们怎么知道哪些是前台任务，哪些是后台任务，fork时告诉我们吗？</li>
<li>gcc就一点不需要交互吗？Ctrl+C按键怎么工作？word就不会执行一段批处理吗？Ctrl+F按键？ </li>
<li>SJF中的短作业优先如何体现？如何判断作业的长度？这是未来的信息…</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xwdidi.com/2018/09/25/2018-09-25-L13操作系统那颗树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xuwei98">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="偽のブログ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/25/2018-09-25-L13操作系统那颗树/" itemprop="url">进程与线程         L13 操作系统那颗树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-25T00:00:00+08:00">
                2018-09-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/25/2018-09-25-L13操作系统那颗树/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/09/25/2018-09-25-L13操作系统那颗树/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  621
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前文重点"><a href="#前文重点" class="headerlink" title="前文重点"></a>前文重点</h2><ol>
<li><p>cpu执行</p>
</li>
<li><p>进程 线程</p>
</li>
<li><p>实现多进程图像，</p>
</li>
<li><p>用户级线程 内核级线程</p>
</li>
<li><p>多线程切换</p>
</li>
</ol>
<h2 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h2><ul>
<li>运转CPU，pc指针置为需要的初始值，取值执行，不断运转</li>
<li>存在I\O，无法有效利用CPU</li>
<li>提高CPU的利用率，学会切换运行程序</li>
<li>通过栈的数据结构实现程序间的跳转</li>
<li>如何跳回原来的栈呢， 做成两个栈</li>
<li>用TCB存储信息，作为切换的线索</li>
<li>用户态执行单一，容易堵塞，、</li>
<li>内核态线程，引入两套栈，引入内核栈</li>
<li>通过TCB切换内核栈，再切回到用户栈</li>
</ul>
<h4 id="如何实现linux0-01的，交替打出AB"><a href="#如何实现linux0-01的，交替打出AB" class="headerlink" title="如何实现linux0.01的，交替打出AB"></a>如何实现linux0.01的，交替打出AB</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AB.C</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!fork())&#123;<span class="keyword">while</span>(<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"A"</span>);&#125;</span><br><span class="line">    <span class="keyword">if</span>(!fork())&#123;<span class="keyword">while</span>(<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"A:);&#125;</span></span><br><span class="line"><span class="string">    wait();</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">    mov __NR_fork, %eax</span><br><span class="line">    int 0x80			//系统调用，中断，进入内核，</span><br><span class="line">100: mov %eax, res		//调用成功后 ，eax的值赋值给res</span><br><span class="line">	cmpl res,0</span><br><span class="line">	jne 208			//根据返回值，跳转</span><br><span class="line">200: printf(&quot;A&quot;)</span><br><span class="line">	jmp 200</span><br><span class="line">208:...</span><br><span class="line">304: wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>int 0x80中断，进入内核，通过set_system_gate初始化好的system_call表进入到sys_call_table中，执行sys_fork,跳转到copy_process.</p>
<p>cpoy_process,做出新的PCB,栈.将各种参数eip,esp,eax置为父进程的相关参数  .做出相关结构体,和栈实现打出A的程序 </p>
<p>父进程返回,开始调度打出A的程序,在中断返回时执行reschedule</p>
<p>又一个fork;再一次int 0x80;在内核中再产生一个PCB和内核栈.存在两个PCB形成了队列.</p>
<p>让父进程进行阻塞态,调用schdule根据算法选择一个进程执行,通过switch_to进行切换,保存当前tss,然后需要切换的tss提交给cpu.就能打出A了.</p>
<p>通过执行另一个程序,打出B的话.如何交替打出AB,通过调度点 .通过时钟中断,切换程序实现交替打出AB</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> sched <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//在sched.c中</span></span></span><br><span class="line"><span class="function"></span>&#123;set_intr_gate(<span class="number">0x20</span>,&amp;timer_interrupt);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> _timer_interrupt:</span><br><span class="line">	...</span><br><span class="line">	call do_timer </span><br><span class="line">    </span><br><span class="line"><span class="keyword">void</span> <span class="keyword">do</span> timer（...）</span><br><span class="line">&#123;<span class="keyword">if</span>（（--current-&gt;counter&gt;<span class="number">0</span>）<span class="keyword">return</span>;</span><br><span class="line">current-&gt;counter=<span class="number">0</span>;</span><br><span class="line">    schedule()；&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">    mov __NR_fork, %eax</span><br><span class="line">    int 0x80			</span><br><span class="line">100: mov %eax, res		</span><br><span class="line">	cmpl res,0</span><br><span class="line">	jne 208			</span><br><span class="line">200: printf(&quot;A&quot;)</span><br><span class="line">	jmp 200</span><br><span class="line">208:...</span><br><span class="line">300:printf(&quot;B&quot;)</span><br><span class="line">	jmp 300</span><br><span class="line">308: wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间片变为0时,切换程序.调用schedule,通过tss切换栈执行用户程序. 最后形成了交替</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果能根据这些思路,写出linux0.11 或者理解出系统背后真正的执行.对于之后的路有莫大的基础支撑.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xwdidi.com/2018/09/18/2018-09-18-L12内核级线程实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xuwei98">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="偽のブログ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/18/2018-09-18-L12内核级线程实现/" itemprop="url">进程与线程     L12 内核级线程实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-18T00:00:00+08:00">
                2018-09-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/18/2018-09-18-L12内核级线程实现/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/09/18/2018-09-18-L12内核级线程实现/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="课程回顾"><a href="#课程回顾" class="headerlink" title="课程回顾"></a>课程回顾</h4><p>核心：由PCB引发的栈的切换</p>
<p>两套栈之间的切换，实现内核级线程的切换</p>
<ul>
<li>TCB的切换</li>
<li>切换了内核栈</li>
<li>通过IRET切换到用户栈</li>
</ul>
<h2 id="课程重点"><a href="#课程重点" class="headerlink" title="课程重点"></a>课程重点</h2><p>学会线程的代码实现，促进进程代码的了解，再加上对于内存管理的代码实现，就是实现了进程。</p>
<h3 id="实现代码解析"><a href="#实现代码解析" class="headerlink" title="实现代码解析"></a>实现代码解析</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mian()&#123;</span><br><span class="line">A();</span><br><span class="line">B();</span><br><span class="line">&#125;</span><br><span class="line">A();</span><br><span class="line">&#123;</span><br><span class="line">fork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户栈：main：<br>​      ret = exit<br>​    A: ret = B</p>
<p>在A()中执行，遇到fork  //系统调用，启动中断，准备进入内核</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov %eax,__NR_fork</span><br><span class="line">INT	0x80</span><br><span class="line">mov res,%eax</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main:			 	用</span><br><span class="line">ret = exit			户</span><br><span class="line">A: ret = B			栈</span><br><span class="line">__________________________</span><br><span class="line">ss:sp									内</span><br><span class="line">EFLAGS	//	提供对程序的状态及相应的控制		核</span><br><span class="line"></span><br><span class="line">ret = ptr(mov res,%eax)						栈</span><br><span class="line">system_call</span><br></pre></td></tr></table></figure>
<p>在中断前进行了压栈，SS:SP是用户栈的地址，ret中压入了下一个指令的地址（CS：IP），??2是mov res,%eax的地址，??1为当前的eip，就是需要执行的下一个代码。</p>
<p>中断后当然是访问system_call啦，通过set_system_gate设置中断处理表，通过system_call 调用表，调用系统调用fork，而在调用fork之前，还要对其他参数进行压栈。</p>
<p><img src="https://i.loli.net/2018/09/18/5ba1089c5fe4f.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void sched init(void)</span><br><span class="line">&#123;set_system gate(0x80,&amp;system_cal1);&#125;</span><br><span class="line"></span><br><span class="line">system_cal1: </span><br><span class="line">push  $ds..&amp; fs 	//压栈，方式寄存器指向TIB</span><br><span class="line">pushl $edx...</span><br><span class="line">call sys_fork 		//调用fork</span><br><span class="line">pushl %eax</span><br><span class="line">-------------------</span><br><span class="line">movl _current,%eax 	//将TCB的信息放入eax中</span><br><span class="line">cmp1 $0,state(&amp;eax)	//检验是否为阻塞态</span><br><span class="line">jne _reschedule		//若为阻塞态，跳到重新调度函数</span><br><span class="line">cmpl $0,counter(&amp;eax) //比较时间片大小</span><br><span class="line">je	reschedule		//若时间片大小为0，也跳到重新调度函数</span><br><span class="line">ret_from_sys_call：	//从中断返回函数</span><br><span class="line">--------------------</span><br><span class="line">reschedule:</span><br><span class="line">pushl $ret_from_sys_call	//压入函数地址，</span><br><span class="line">jmp	_sceduld		//执行完调度函数后，跳回中断返回函数</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    next = i;</span><br><span class="line">    switch_to(next);		<span class="comment">//切换TCB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret_from_sys_call:</span><br><span class="line">	popl %eax 	//返回值</span><br><span class="line">	popl %ebx	...</span><br><span class="line">	pop %fs</span><br><span class="line">	iret	//重要,返回到int 0x80后面执行</span><br></pre></td></tr></table></figure>
<h4 id="switch-to详解"><a href="#switch-to详解" class="headerlink" title="switch_to详解"></a>switch_to详解</h4><p>除了linux0.11这种小型系统，现代操作系统都是基于TSS（intel结构）的切换，而实验四实现内核栈的切换（kernelstack）</p>
<p><img src="https://i.loli.net/2018/09/19/5ba1b6750c11e.jpg" alt></p>
<p>这是一个TSS(task state segment)示意图，TSS的访问是通过TR寄存器中的选择符寻找到TSS描述符，再访问到TSS段中，从TSS段中取各个寄存器的值。在这之前也会通过TSS保存之前用户栈的相关寄存器的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> switch to(n)</span></span><br><span class="line">&#123; <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">long</span> a,b;&#125;</span><br><span class="line">__asm__(</span><br><span class="line"><span class="string">"movw %%dx,%1\n\t"</span></span><br><span class="line"><span class="string">"ljmp %0\n\t"</span>		<span class="comment">//ljmp长跳转指令，跳入到%0的64位地址，%0是第一个操作数</span></span><br><span class="line"></span><br><span class="line">::<span class="string">"m"</span>(*&amp;__tmp.a),	<span class="comment">//前32位</span></span><br><span class="line"></span><br><span class="line"><span class="string">"m"</span>(*&amp; __tmp.b),	<span class="comment">//后32位</span></span><br><span class="line"></span><br><span class="line"><span class="string">"d"</span>((_TSS(n))		<span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>Linux 0.11用tss切换，但也可以用栈切换，因为tss中的信息可以写到内核栈中</p>
<p>TR寄存器可以找到当前的TSS，然后将TSS中中的信息“拍照”放入到段TSS中，再在新的TR中寻找到段TSS，获得新的内核栈信息</p>
<h4 id="sys-fork中的ThreadCreate"><a href="#sys-fork中的ThreadCreate" class="headerlink" title="sys_fork中的ThreadCreate"></a>sys_fork中的ThreadCreate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sys_fork:</span><br><span class="line">push %gs;</span><br><span class="line">pushl %esi </span><br><span class="line">...</span><br><span class="line">pushl %eax </span><br><span class="line">call _copy_process,   //通过父进程的代码，创建新进程</span><br><span class="line">add1 %20,%esp </span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_process</span><span class="params">(<span class="keyword">int</span> nr,<span class="keyword">long</span> ebp, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">long</span> edi,<span class="keyword">long</span> esi,<span class="keyword">long</span> gs,<span class="number">1</span>ong </span></span></span><br><span class="line"><span class="function"><span class="params">none,<span class="keyword">long</span> ebx,<span class="keyword">long</span> ecx,<span class="keyword">long</span> edx,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">1</span>ong fs,<span class="keyword">long</span> es,<span class="keyword">long</span> ds,<span class="keyword">long</span> eip,</span></span></span><br><span class="line"><span class="function"><span class="params">longcs,<span class="keyword">long</span> eflags,<span class="keyword">long</span> esp,<span class="keyword">long</span> ss)</span></span></span><br></pre></td></tr></table></figure>
<p>通过拷贝函数，将栈中的参数传递给copy_process，函数中最后的执行的参数是在参数中的最上面。</p>
<p>eip为??2。</p>
<p>  <img src="https://i.loli.net/2018/09/19/5ba1c126ef89d.jpg" alt></p>
<h5 id="创建栈"><a href="#创建栈" class="headerlink" title="创建栈"></a>创建栈</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p=（struct_task_struct*)get_free_page();<span class="comment">//获得一页内存，不能使用用户态代码malloc。强制转化为TCP格式。</span></span><br><span class="line"><span class="comment">//申请内存空间</span></span><br><span class="line">    </span><br><span class="line">p-&gt;tss.esp0=PAGE_SIZE+(<span class="keyword">long</span>)p; <span class="comment">//初始内核栈</span></span><br><span class="line">p-&gt;tss.ss0=<span class="number">0x10</span>；</span><br><span class="line"><span class="comment">//创建内核栈</span></span><br><span class="line"></span><br><span class="line">p-&gt;tss.ss=ss &amp; OXffff;		<span class="comment">//使用了父进程的相关参数</span></span><br><span class="line">p-&gt;tss.esp = esp;			<span class="comment">//相同用户栈</span></span><br><span class="line"><span class="comment">//创建用户栈（和父进程共用栈）</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2018/09/19/5ba1c5f54ce8a.jpg" alt></p>
<p>做了以下操作</p>
<ol>
<li>申请内存空间</li>
<li>创建TCB</li>
<li>创建内核栈和用户栈</li>
<li><del>填写两个stack</del></li>
<li>关联栈和TCB</li>
</ol>
<h5 id="执行前的准备"><a href="#执行前的准备" class="headerlink" title="执行前的准备"></a>执行前的准备</h5><p><img src="https://i.loli.net/2018/09/19/5ba1cd13a6e97.jpg" alt></p>
<h5 id="如何执行子进程"><a href="#如何执行子进程" class="headerlink" title="如何执行子进程"></a>如何执行子进程</h5><p>linux0.11不支持线程，但是可以通过shell的执行，去学习子进程的执行方式。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,cmd); </span><br><span class="line">		<span class="keyword">if</span>(!fork())</span><br><span class="line">			(exec(cmd)wait(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fork()0何时返回0，何时不会？首先要知道fork（）怎么返回？<br><img src="https://blog.csdn.net/THEONE10211024/article/details/13774669" alt="fork函数详解"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov %eax, __NR_fork</span><br><span class="line">INT 0x80</span><br><span class="line">mov res,%eax</span><br></pre></td></tr></table></figure>
<p>父进程用iret，要从核心态返回到用户态，那么子进程呢，ljmp tss</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;tss.eip=eip; </span><br><span class="line">p-&gt;tss.cs=cs;</span><br><span class="line">p-&gt;tss.eax=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="子进程进入A，父进程等待"><a href="#子进程进入A，父进程等待" class="headerlink" title="子进程进入A，父进程等待"></a>子进程进入A，父进程等待</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!fork())&#123;exec(cmd)&#125;</span><br><span class="line">_system_call:</span><br><span class="line">	push %ds .. %fs</span><br><span class="line">	pushl %edx...</span><br><span class="line">     call sys_execve	<span class="comment">//进入到内核态，中断返回将会去执行entry 入口</span></span><br></pre></td></tr></table></figure>
<p>如何让ip指针去指向sys_execve，这时候有个想法就是将28出ret弹出时的指针改变，到时候就能去直接执行入口函数。</p>
<p><img src="https://i.loli.net/2018/09/19/5ba1daf4db052.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_sys_execve: </span><br><span class="line">lea EIP(&amp;esp),%eax //EIP在栈中的偏移地址</span><br><span class="line">pushl %eax </span><br><span class="line">call _do_execve</span><br></pre></td></tr></table></figure>
<p><code>EIP = 0x1c</code>大小就为28，将地址压入栈中，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_execve</span><span class="params">(*eip,…</span></span></span><br><span class="line"><span class="function"><span class="params">&#123;p+=change_ldt(...;</span></span></span><br><span class="line"><span class="function"><span class="params">eip[<span class="number">0</span>]=ex.a_entry;	<span class="comment">//程序从磁盘加载，将文件头中的地址赋予相应位置</span></span></span></span><br><span class="line"><span class="function"><span class="params">eip[<span class="number">3</span>]=p;.…</span></span></span><br><span class="line"><span class="function"><span class="params">----------</span></span></span><br><span class="line"><span class="function"><span class="params">struct exec&#123;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">long</span> a magic;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> a_entry;<span class="comment">//入口&#125;；</span></span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eip[<span class="number">0</span>]=esp+<span class="number">0x1C</span>;</span><br><span class="line">eip[<span class="number">3</span>]=esp+<span class="number">0x1C</span>+<span class="number">0X0C</span>=esp+<span class="number">0x28</span>	<span class="comment">//(正好是SP)</span></span><br></pre></td></tr></table></figure>
<p>在中断时，就压入入口函数地址，并在之后的系统调用中，压入+28栈中地址，改写栈中28的数据为入口函数的地址，方便调用。</p>
<p>弹出后能直接执行</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>记住这幅图！。写好核心代码，。一层一层搭建出来操作系统</p>
<p><img src="https://i.loli.net/2018/09/19/5ba1e15434213.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://xwdidi.com/2018/09/13/2018-09-15-L11内核级线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xuwei98">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="偽のブログ">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/13/2018-09-15-L11内核级线程/" itemprop="url">进程与线程     L11 内核级线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-13T00:00:00+08:00">
                2018-09-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/13/2018-09-15-L11内核级线程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/09/13/2018-09-15-L11内核级线程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="课程回顾"><a href="#课程回顾" class="headerlink" title="课程回顾"></a>课程回顾</h3><p>用户级线程，一个栈变为两个栈，先切换PCB，再切换栈，再从栈中弹出地址(ret),再去执行</p>
<h1 id="课程重点总结"><a href="#课程重点总结" class="headerlink" title="课程重点总结"></a>课程重点总结</h1><p>切换进程是切换内核级线程，切换用户级线程是内核级线程的一部分。</p>
<p>进程只能存在内核中，要分配资源，访问文件，都是有系统控制分配的。所以没有用户级进程</p>
<h2 id="核心级线程"><a href="#核心级线程" class="headerlink" title="核心级线程"></a>核心级线程</h2><h3 id="多处理器与多核的区别"><a href="#多处理器与多核的区别" class="headerlink" title="多处理器与多核的区别"></a>多处理器与多核的区别</h3><p>MMU：内存管理单元 Memory Management Unit，</p>
<ul>
<li>管理虚拟存储器、物理存储器的控制线路，</li>
<li>同时也负责虚拟地址映射为物理地址，</li>
<li>以及提供硬件机制的内存访问授权，多用户多进程操作系统。</li>
</ul>
<p>多处理器：CPU有自己的MMU，</p>
<p>多核：多个CPU共用一个MMU，这不就是线程吗，多核并行。</p>
<p>多个线程执行在多个核上，共用MMU，这不就是典型的多线程吗，多核发挥的效果就是并行，与并发进行区别。而用户级线程无法调动硬件，实现不了多核利用。</p>
<h3 id="用户级线程与和核心级线程的区别"><a href="#用户级线程与和核心级线程的区别" class="headerlink" title="用户级线程与和核心级线程的区别"></a>用户级线程与和核心级线程的区别</h3><p><img src="https://i.loli.net/2018/09/15/5b9cd714361a9.jpg" alt></p>
<ul>
<li><p>每个程序都有自己的栈，一个或者两个，然而在核心级线程中从一个栈到一套栈；两个栈到两套栈。</p>
</li>
<li><p>内核态中线程需要执行函数调用，需要拥有自己的内核栈，实现用户级线程的核心是一个栈变成两个栈，实现内核级线程的核心是一套站变成两套栈。</p>
</li>
<li><p>用户栈根据TCB，切换一个栈。而内核栈中，根据TCB切换一套栈，用户栈和内核栈。</p>
</li>
</ul>
<h4 id="用户栈与内核栈之间的关联"><a href="#用户栈与内核栈之间的关联" class="headerlink" title="用户栈与内核栈之间的关联"></a>用户栈与内核栈之间的关联</h4><p>一旦启动中断(时钟、外设、int指令），就会调用内核栈，记录用户态执行的地方（压栈SS，SP，PC，CS），内核栈通过指针和用户栈相连。</p>
<p>IRET，返回，将五个寄存器弹回，切回到用户态执行的地方。<img src="https://i.loli.net/2018/09/15/5b9cdfdfb934c.jpg" alt></p>
<h4 id="程序实例"><a href="#程序实例" class="headerlink" title="程序实例"></a>程序实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">100:A()&#123;</span><br><span class="line">	B();</span><br><span class="line">104:&#125;</span><br><span class="line">200:B()&#123;</span><br><span class="line">	read();</span><br><span class="line">204:&#125;</span><br><span class="line">300:read()&#123;</span><br><span class="line">	int 0x80;</span><br><span class="line">304:&#125;</span><br><span class="line">// 用户程序</span><br><span class="line"></span><br><span class="line">/////////////////</span><br><span class="line"></span><br><span class="line">//内核程序</span><br><span class="line"></span><br><span class="line">system_call: </span><br><span class="line">	call sys_read;</span><br><span class="line">1000:</span><br><span class="line">2000:sys_read()&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>用户栈中执行函数调用，将104，204压入栈中，然后执行read（），是函数库中函数，接着调用int 0x80,通过中断进入操作系统内核，此时将各种寄存器参数压入参数中，304为中断后需要执行的地址。CS指向用户态的首地址，1000为系统调用后需要执行的地址。</p>
<p><img src="https://i.loli.net/2018/09/15/5b9ce3798bad1.jpg" alt></p>
<h4 id="内核中的切换：switch-to"><a href="#内核中的切换：switch-to" class="headerlink" title="内核中的切换：switch_to"></a>内核中的切换：switch_to</h4><p><code>sys_read(){启动磁盘读；将自己变成阻塞；找到next；switch_to(cur，next)；}</code>,cur和next都是TCB，TCB中存放着内核栈指针，根据TCB中的地址将esp切到了另一个内核栈的esp地址，然后通过ret弹出切到某个内核程序，最后再通过CS:PC切到用户程序。</p>
<p>用户级线程进入到内核，切换内核级线程，再返回去继续执行在用户态执行。</p>
<p>下面是切换后的内核栈,需要通过第五个格子切换到用户态，所以根据之前的学习，应该是包括IRET（中断返回）的代码，将用户栈和CS:IP指向的用户态代码返回正确。  一段能完成第二级返回的代码，一段包含IRET的代码。</p>
<p><img src="https://i.loli.net/2018/09/15/5b9ce661dc2e7.jpg" alt></p>
<h4 id="内核态切换的简单总结"><a href="#内核态切换的简单总结" class="headerlink" title="内核态切换的简单总结"></a>内核态切换的简单总结</h4><p>用户态通过中断切换到内核，如果被阻塞，需要切换到另一个内核级线程时，通过PCB中的信息，切换内核栈，再通过IRET指令切换到另一个用户栈。</p>
<h3 id="内核级线程switch-to的五段论"><a href="#内核级线程switch-to的五段论" class="headerlink" title="内核级线程switch_to的五段论"></a>内核级线程switch_to的五段论</h3><ol>
<li><p>中断入口：（进入切换）<br>push ds；…pusha；<br>mov ds，内核段号；..<br>cal1中断处理<br>？？：<br><strong>找到TCB</strong></p>
</li>
<li><p>中断处理：（引发切换）<br>启动磁盘读或时钟中断；<br>schedule（）；<br>}//ret<br><strong>阻塞</strong></p>
</li>
<li><p>schedule:next=..;<br> call switch to;<br>  }//ret<br> <strong>完成内核栈的切换</strong></p>
</li>
<li>switch_to:（内核栈切换）<br>TCB[cur].esp=%esp;<br>%esp=TCB[next].esp;<br>ret<br><strong>esp指针指向IRET代码段</strong></li>
<li>中断出口：（第二级切换）<br>popa；..…；pop ds;<br>iret<br><strong>完成用户栈的切换，和代码段的地址切换</strong></li>
<li>S、T非问一进程：（地址切换）要首先切换地址映射表；<br>TCB[cur].1dtr=%ldtr<br>%1dtr=TCB[next].ldtr<br>//内存管理<br><strong>切换映射表</strong></li>
</ol>
<h4 id="实现ThreadCreate"><a href="#实现ThreadCreate" class="headerlink" title="实现ThreadCreate"></a>实现ThreadCreate</h4><p>用户栈 + 内核栈 + TCB</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadCreate</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TCB tcb = get_free_page();	<span class="comment">//申请一片内存用作TCB，并进行初始化</span></span><br><span class="line">    </span><br><span class="line">    *krlstack=...;		<span class="comment">//申请一片内存作为内核栈，</span></span><br><span class="line">   </span><br><span class="line">    *userstack传入;</span><br><span class="line">     <span class="comment">//填写两个stack；</span></span><br><span class="line">    <span class="comment">//修改CS为0f，（后面会提到）</span></span><br><span class="line">    </span><br><span class="line">    tcb.esp=krlstack; <span class="comment">//TCP状态指向中断出口</span></span><br><span class="line">    </span><br><span class="line">    tcb.状态=就绪;</span><br><span class="line">    tcb入队;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2018/09/15/5b9cf0f302dc4.jpg" alt></p>
<h3 id="用户级线程、核心级线程的对比"><a href="#用户级线程、核心级线程的对比" class="headerlink" title="用户级线程、核心级线程的对比"></a>用户级线程、核心级线程的对比</h3><table>
<thead>
<tr>
<th></th>
<th>用户级线程(业务代码)</th>
<th>核心级线程</th>
<th>用户+核心级</th>
</tr>
</thead>
<tbody>
<tr>
<td>实现模型</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>利用多核</td>
<td>差</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td>并发度</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>代价</td>
<td>小</td>
<td>大</td>
<td>中</td>
</tr>
<tr>
<td>内核改动</td>
<td>无</td>
<td>大</td>
<td>大</td>
</tr>
<tr>
<td>用户灵活性</td>
<td>大</td>
<td>小</td>
<td>大</td>
</tr>
</tbody>
</table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>明白了进程中执行代码怎么切换的，用线程的观点讲解进程，</p>
<p><strong>最后要通过进行<a href="https://www.shiyanlou.com/courses/115" target="_blank" rel="noopener">第四次实验</a>进行巩固学习。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Xuwei98">
            
              <p class="site-author-name" itemprop="name">Xuwei98</p>
              <p class="site-description motion-element" itemprop="description">圈地自萌,自娱自乐</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">51</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Xuwei98" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:z1002280879@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
<br>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1350129459&auto=1&height=66"></iframe>

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xuwei98</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">47.7k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://xuwei98.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
