<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>偽のブログ</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xwdidi.com/"/>
  <updated>2019-04-07T08:11:49.014Z</updated>
  <id>http://xwdidi.com/</id>
  
  <author>
    <name>Xuwei98</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019-04-07-断点原理</title>
    <link href="http://xwdidi.com/2019/04/07/2019-04-07-%E6%96%AD%E7%82%B9%E5%8E%9F%E7%90%86/"/>
    <id>http://xwdidi.com/2019/04/07/2019-04-07-断点原理/</id>
    <published>2019-04-07T05:33:23.000Z</published>
    <updated>2019-04-07T08:11:49.014Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="CC断点"><a href="#CC断点" class="headerlink" title="CC断点"></a>CC断点</h3><p>F2断点.\</p><p>设置无数个.</p><p>将断下的指令地址处的第一个字节设置为0xCC</p><p>0xCC对应<code>int3</code>,专门用来调试的中断指令.</p><p>触发EXCEPTION_BREAKPOINT的异常,进行相应的处理</p><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><p>检测首地址是否为CCH</p><h3 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h3><p>或者是<code>PAGE_GUARD</code></p><blockquote><p>A: 内存访问断点，OD将目标内存所在的页面（范围圆整为1000h的倍数）设置为PAGE_NOACCESS，当被调试程序对这个内存进行任何“读、写或运行”操作时，都会触发异常。</p><p>B: 内存写入断点，OD将目标内存所在的页面（范围圆整为1000h的倍数）设置为PAGE_EXECUTE_READ，当被调试程序对这个内存进行“写”操作时触发异常。</p></blockquote><h4 id="检测-1"><a href="#检测-1" class="headerlink" title="检测"></a>检测</h4><p>我们使用VirtualProtectEx进行内存页修改,通过GetLastError获取到的值进行判断,进行相关处理</p><h4 id="反反内存断点"><a href="#反反内存断点" class="headerlink" title="反反内存断点"></a>反反内存断点</h4><p>VirtualQuery，VirtualQueryEx，VirtualProtect，VirtualProtectEx</p><h3 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a>硬件断点</h3><p>利用CPU自带的调试寄存器DR0-DR3设置硬件断点,产生SINGLE_STEP异常.</p><p>四个寄存器 最多四个断点.</p><p>DR7是控制位,控制断点方式.DR6显示断点原因</p><p><strong><a href="https://www.pediy.com/kssd/pediy06/pediy6751.htm" target="_blank" rel="noopener">学习大佬的文章</a></strong></p><h3 id="单步执行"><a href="#单步执行" class="headerlink" title="单步执行"></a>单步执行</h3><ol><li><p>通过调试符号获取当前对应的行信息, 并保存该信息.</p></li><li><p>设置TF位, 开始CPU的单步执行,产生单步异常</p></li><li><p>处理单步执行异常程序,TF置为0 </p></li></ol><pre><code>等读完张银奎老师的软件调试再来做细致修改和改正</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="逆向分析" scheme="http://xwdidi.com/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
    
      <category term="断点" scheme="http://xwdidi.com/tags/%E6%96%AD%E7%82%B9/"/>
    
      <category term="调试" scheme="http://xwdidi.com/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>VC：执行远程线程注入的代码段导致目标进程崩溃</title>
    <link href="http://xwdidi.com/2019/04/01/2019-04-01-VC%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5%E5%A4%B1%E8%B4%A5/"/>
    <id>http://xwdidi.com/2019/04/01/2019-04-01-VC线程注入失败/</id>
    <published>2019-03-31T16:00:00.000Z</published>
    <updated>2019-04-07T04:36:27.147Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天使用植物大战僵尸练习线程注入调用call的时候,一直处于崩溃状态,,后来查阅了教程博客,下面有人指出了问题所在 在此引用下老哥的博客文章.</p><p><a href="https://blog.csdn.net/kk20078733/article/details/5530884" target="_blank" rel="noopener">原文地址</a></p><blockquote><p>以前也曾多次提到远程线程注入导致进程崩溃的现象。</p><p>此次崩溃不同于前几次。</p><p>之前，采用的是dll注入的方式，注入后，由于同一个dll文件在不同的进程中映射的基地址不同，导致远程线程函数的入口地址不同，以至崩溃，这种情况，多数是本进程采用静态链接加载待远程注入的dll文件，而其他进程则动态加载该dll文件，两次加载将在内存中产生两个dll实例。</p><p>此次，需要向远程进程注入代码段，远程线程函数入口地址正确。测试时，为了方便，特地增加了一个消息框MessageBox，远程线程函数仅仅调用这个弹出消息框的函数，然后退出。结果，消息框正常弹出，但是，当点击确定退出消息框后，目标进程立即崩溃。原因不明。</p><p>200807210756注：</p><p>实在不知道问题出哪儿了，于是就想看看注入的VC代码对应的反汇编代码，这时，忽然想到一点，即：我都是在Debug模式下执行的，这可能会有问题。</p><p>进一步思考。Debug版本和Release版本最大的不同在于，每次调用一个函数后，Debug版本会进行堆栈检测。而目标进程显然是处于release模式，此时，如果注入的是Debug版本的代码，那么，调用函数之后，会有一句检测堆栈的机器指令，这很可能就是进程崩溃的原因所在。</p><p>于是，改为release环境测试，一切正常！OK！</p><p>(我用控制台程序实现时没有问题，用MFC程序实现就有问题，因此发现以上内容，将Debug版改为Release版就没问题了)</p><p>另附上远程注入的主要代码段，供参考，有问题望指教！！！</p><p>作者：kk20078733<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/kk20078733/article/details/5530884" target="_blank" rel="noopener">https://blog.csdn.net/kk20078733/article/details/5530884</a> </p></blockquote><p>Debug版会使用一个检查堆栈平衡的函数_checkesp..</p><p>详细的在小黄书中有讲到.现在记得不是很清楚.</p><p>有机会的话会写上来.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="windows编程" scheme="http://xwdidi.com/categories/windows%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="错误整理" scheme="http://xwdidi.com/tags/%E9%94%99%E8%AF%AF%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>设备驱动与文件系统   L30 文件使用的磁盘的实现</title>
    <link href="http://xwdidi.com/2019/03/04/2019-03-04-L30-%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8%E7%A3%81%E7%9B%98%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://xwdidi.com/2019/03/04/2019-03-04-L30-文件使用磁盘的实现/</id>
    <published>2019-03-03T16:00:00.000Z</published>
    <updated>2019-04-06T13:57:07.175Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="上文总结"><a href="#上文总结" class="headerlink" title="上文总结"></a>上文总结</h2><p>从字符流算出盘块号</p><p>使用映射表算出.</p><h2 id="重点总结"><a href="#重点总结" class="headerlink" title="重点总结"></a>重点总结</h2><p><code>fs/read_write.c</code></p><p><img src="https://i.loli.net/2019/03/04/5c7d2647b2806.jpg" alt></p><p>参数分别是文件描述符,缓冲区,读写字符的个数.处理字符流的一段</p><p>获得inode(FCB),根据字符流的位置算出盘块号,读就完事了.</p><p>给出inode,file,缓冲区,长度, 运行file_write,取出对应盘块号的信息放入队列中,进行修改,再存入.</p><p>,</p><p>,</p><h3 id="file-write的工作流程"><a href="#file-write的工作流程" class="headerlink" title="file_write的工作流程"></a>file_write的工作流程</h3><p>(1)首先需要知道是些哪段字符？<br>file中一个读写指针，是开始地址（fseek就是修改它），再加正count</p><p><img src="https://i.loli.net/2019/03/04/5c7d359eedac2.jpg" alt></p><p><code>filp-&gt;f_pops</code>为读写位置,不断累加.追加指针放到文件末尾或者从中读取放到上一次读写的位置.</p><p>根据读写位置找到盘块号.读取到内存缓冲区,放到电梯队列上阻塞.读写完成后后pos增加,文件指针往后挪动</p><p>（2）找到要写的盘块号？<br>inode就是用来干这事的</p><p><img src="https://i.loli.net/2019/03/04/5c7d3967a4d57.jpg" alt></p><p>2^16*1024= 65536kb</p><p>一页索引1024,一个盘块号2个字节,只能表示512索引块.</p><p>根据读写的位置除以每一个读写的位置,字符流的位置除以表示每个块的大小,在哪个段上,再查证映射表对应的盘块号.再使用bread发出磁盘读写</p><p>添加new_block,需要先读入索引块确定正确位置</p><p>inode可以存放映射表,对于特殊文件可以存放设备号等信息</p><p>（3）用盘块号、buf等形<br>成request放入“电梯”</p><p><img src="https://i.loli.net/2019/03/04/5c7d3a8119558.jpg" alt></p><p>i_mode字符文件</p><p>i_zone是存放映射关系的,现在可以用来存放设备号</p><p>通过inode得到文件视图,如何打开文件</p><p>fd = open()<br>read(fd,…)</p><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>从路径名/文件名找到inode,inode找到盘块号,盘块号放到电梯队列,根据盘块号算出chs,</p><p>根据out指令发出到磁盘控制器,驱动马达 电生磁 磁生电形成数据.</p><p><img src="https://i.loli.net/2019/03/05/5c7d5aba2d9a2.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="操作系统" scheme="http://xwdidi.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://xwdidi.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="驱动" scheme="http://xwdidi.com/tags/%E9%A9%B1%E5%8A%A8/"/>
    
      <category term="I/O" scheme="http://xwdidi.com/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>设备驱动与文件系统    L29 从生磁盘到文件</title>
    <link href="http://xwdidi.com/2019/02/19/2019-02-19-L29-%E4%BB%8E%E7%94%9F%E7%A3%81%E7%9B%98%E5%88%B0%E6%96%87%E4%BB%B6/"/>
    <id>http://xwdidi.com/2019/02/19/2019-02-19-L29-从生磁盘到文件/</id>
    <published>2019-02-18T16:00:00.000Z</published>
    <updated>2019-04-06T13:56:53.862Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>如何从文件得到盘块号!</strong></p><p>###为什么引入文件</p><ul><li><p>引入第三层抽象.</p><p>让普通用户使用raw disk,操作信息更加简单.</p><p>用户眼中的文件是字符流的样子</p><p>而磁盘上的文件盘块接在一起.</p><ul><li>方法:建立字符流到盘块集合的映射关系<ul><li>映射的作用:字符流对应相应盘块号,处理相关字符就处理对应的盘块,与内存缓冲区进行交互.然后电梯队列进行写入,修改.</li></ul></li><li>操作系统封装了映射,对用户隐藏细节.</li></ul><h3 id="实现文件的数据结构"><a href="#实现文件的数据结构" class="headerlink" title="实现文件的数据结构"></a>实现文件的数据结构</h3><p>唯一的算出相应的盘块</p><ul><li><p>连续结构,</p><p>映射表中存放各个字符流的首地址和使用块数</p><p><img src="https://i.loli.net/2019/02/19/5c6b0ad3a8a7e.jpg" alt></p><p>局限性:文件需要整体拷贝,效率低下.直接存取很快,类似于数组,动态增长很吃力</p></li><li><p>链式结构实现文件(链表)</p><p>适合动态增长</p><p>局限性:存取慢</p></li><li><p>索引结构</p><p>有一个块专门做索引提供文件的对应盘块号</p><p><img src="https://i.loli.net/2019/02/19/5c6b10f402a56.jpg" alt></p></li></ul><ol><li>根据FCB先读入索引表</li><li>一旦开始读写200-212,就把索引块读出来,然后查找200-212,若对应1号盘块,则读写改变</li></ol><p>比链式结构块!,既适合读取也适合增长</p></li></ul><h3 id="实际系统使用的数据结构"><a href="#实际系统使用的数据结构" class="headerlink" title="实际系统使用的数据结构"></a>实际系统使用的数据结构</h3><p><strong>多级索引</strong></p><p><img src="https://i.loli.net/2019/02/19/5c6b127d99aba.jpg" alt></p><ul><li>小文件直接读写盘块</li><li>中型通过一阶间接索引读取</li><li>大型使用多级索引</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><p>小文件高校访问</p></li><li><p>可以表示很大的文件</p></li><li><p>中等大小的文件访问也不慢</p></li></ul><p>实现了折中</p><p>通过维护文件中的inode信息,控制FCB信息,得到盘块号.磁盘中断时,从电梯队列中取出来,算出CHS,再通过out发到具体的磁盘马达驱动器上.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="操作系统" scheme="http://xwdidi.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://xwdidi.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="驱动" scheme="http://xwdidi.com/tags/%E9%A9%B1%E5%8A%A8/"/>
    
      <category term="I/O" scheme="http://xwdidi.com/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>设备驱动与文件系统    L28 生磁盘的使用</title>
    <link href="http://xwdidi.com/2019/02/16/2019-02-16-L28-%E7%94%9F%E7%A3%81%E7%9B%98%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://xwdidi.com/2019/02/16/2019-02-16-L28-生磁盘的使用/</id>
    <published>2019-02-15T16:00:00.000Z</published>
    <updated>2019-04-06T13:56:34.504Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前文回顾"><a href="#前文回顾" class="headerlink" title="前文回顾"></a>前文回顾</h3><h3 id="本文重点"><a href="#本文重点" class="headerlink" title="本文重点"></a>本文重点</h3><p>让磁盘直接被使用起来,让磁盘工作起来.</p><p>​    发出一个读命令<br>​    将数据送往内存<br>​    读完后向CPU发出中断</p><ol><li><p>CPU向磁盘驱动器中的寄存器读写数据</p></li><li><p>磁盘控制器完成真正的工作,并向CPU发中断的信号</p></li></ol><h4 id="使用磁盘从认识磁盘开始"><a href="#使用磁盘从认识磁盘开始" class="headerlink" title="使用磁盘从认识磁盘开始"></a>使用磁盘从认识磁盘开始</h4><p><img src="https://i.loli.net/2019/02/15/5c65d554bb1f6.jpg" alt></p><h5 id="如何读-写一字节呢"><a href="#如何读-写一字节呢" class="headerlink" title="如何读/写一字节呢"></a>如何读/写一字节呢</h5><ol><li><p>移动到指定的磁道里</p><p>然后再一转,磁生电,将数据写到内存中</p></li><li><p>数据写入内存中</p><p>移动到指定的磁道里</p><p>转动,电生磁,将数据刻入到磁盘扇区里</p></li></ol><p>   移动磁头,旋转磁盘,和内存缓冲进行读写**</p><h4 id="直接使用磁盘"><a href="#直接使用磁盘" class="headerlink" title="直接使用磁盘"></a>直接使用磁盘</h4><p>程序告诉磁盘控制器’柱面’,’磁头’,’扇区’,’缓存位置’这几个参数</p><p><img src="https://img-blog.csdn.net/20140223134118796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhb21pbnRoZXJl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><p>柱面(C):硬盘中，不同盘片相同半径的磁道所组成的圆柱称为柱面</p><p>磁头(head):根据磁头读相应盘面</p><p>扇区:磁道按相应规则划分具有一定弧度的磁道部分</p><p>不同半径的同心圆称为磁道</p><p>缓冲位置</p><p>根据上速条件,可以利用DMA将磁盘与内存的数据进行交互</p><p><img src="https://i.loli.net/2019/02/15/5c65e378e8694.jpg" alt></p><p>通过out指令将各个参数信息通过移位得到磁盘控制器能识别的数据放到对应的端口上,</p><p>这个办法太过于直接,过于复杂.</p><h3 id="第一层抽象"><a href="#第一层抽象" class="headerlink" title="第一层抽象"></a>第一层抽象</h3><p>通过盘块号读写磁盘</p><ul><li><p>磁盘驱动负责从block计算出cyl，head，sec（CHS）</p><p>隐藏细节,减少用户负担.</p></li><li><p>如何编址呢?为什么这样做呢?</p><p>访问相邻的盘块可以快速读出.</p></li></ul><p>  磁盘访问时间=写入控制器时间+寻道时间(12ms to 8ms)+旋转时间(7200转,4ms半周)+传输时间(50m/s, 0.3s).</p><p>  寻道时间占主要时间,那么就尽量少寻道,所以相邻盘块号应该放在相邻或同一磁道上.</p><h4 id="从CHS到扇区号，从扇区到盘块"><a href="#从CHS到扇区号，从扇区到盘块" class="headerlink" title="从CHS到扇区号，从扇区到盘块"></a>从CHS到扇区号，从扇区到盘块</h4><p>通过C H S计算出block号,CxHxS+HxS+S</p><p><img src="https://i.loli.net/2019/02/16/5c67291c09111.jpg" alt></p><p>寻道时间+旋转时间仍占主要因素.用空间利用率的下降换取效率.的提升.一个盘块就是连续的几个扇区</p><p>根据盘块号访问多个扇区,提升读写速度</p><h4 id="接着使用磁盘-输出block"><a href="#接着使用磁盘-输出block" class="headerlink" title="接着使用磁盘 输出block"></a>接着使用磁盘 输出block</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">make_request</span><span class="params">()</span></span>&#123; <span class="comment">//处理磁盘请求</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span>;</span></span><br><span class="line">req = requrest+NR_REQUEST;</span><br><span class="line">req-&gt;sector = bh-&gt;b_blocknr&lt;&lt;<span class="number">1</span>;<span class="comment">//根据block号算出扇区号,linux0.11的盘块是两个扇区</span></span><br><span class="line">    </span><br><span class="line">add_request(major+blk_dev,req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/02/16/5c674d1f598a9.jpg" alt></p><p>再使用得到的扇区数通过<code>divl</code>指令和<code>block = Cx(SxH)+HxS+S</code>公式得到相应的C H S,柱面磁头扇区</p><p><code>nsect</code>:每个盘块所拥有的扇区数量</p><h3 id="第二层抽象"><a href="#第二层抽象" class="headerlink" title="第二层抽象"></a>第二层抽象</h3><h4 id="多个进程通过队列使用磁盘"><a href="#多个进程通过队列使用磁盘" class="headerlink" title="多个进程通过队列使用磁盘"></a>多个进程通过队列使用磁盘</h4><p><img src="https://i.loli.net/2019/02/16/5c6750ba29511.jpg" alt></p><p>在磁盘驱动时,从请求队列取出.在磁盘中断时,从队列中取出</p><p>第二层抽象的核心在于请求队列中的调度问题,这时候我们来讨论讨论调度算法.(目标是平均访问延迟小,寻道时间是主要矛盾)</p><ol><li>FCFS</li></ol><p>磁盘作旋转运动,磁头在长途奔波.过于追求目的磁道,为何不顺路把路过的磁道也处理了呢?</p><ol start="2"><li><p>SSTF磁盘调度 短寻道优先</p><p>磁头总是在中间柱面晃荡,会造成饥饿</p></li><li><p>最终 : scan 扫描调度(电机算法)</p><p>SSTF+中途不回折:每个请求都有处理的机会</p></li><li><p>c-scan (电梯算法)</p><p>scan+直接移到另一端:两端都能很快的处理</p></li></ol><p><img src="https://i.loli.net/2019/02/16/5c675a3430b8e.jpg" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//终止条件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((IN_ORDER(tmp,req)||!IN_ORDER(tmp,tmp_&gt;next))&amp;&amp;IN_ORDER(req,tmp-&gt;next))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OM_ORDER(s1,s20) \</span></span><br><span class="line">(s1)-&gt;dev&lt;(s2)-&gt;dev||(s1)-&gt;dev ==(s2)-&gt;dev\</span><br><span class="line">&amp;&amp; (s1)-&gt;sector&lt;(s2)_&gt;sector))</span><br><span class="line"><span class="comment">//IN_ORDER满足s1&lt;s2,就是c1&lt;c2根据柱面号排队列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> tmp&lt;req&lt;next</span><br><span class="line"><span class="number">2.</span> tmp&gt;next req&lt;next -&gt;tmp&gt;next&gt;req</span><br></pre></td></tr></table></figure><h4 id="生磁盘使用整理"><a href="#生磁盘使用整理" class="headerlink" title="生磁盘使用整理"></a>生磁盘使用整理</h4><ol><li><p>进程得到盘块号,算出扇区号(sector)</p></li><li><p>用扇区号make req(做出磁盘请求,涉及内存缓冲申请和管理),用电梯算法add_request</p></li><li><p>进程sleep_on()(进程间同步)</p></li><li><p>进行中断处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_intr</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">end_request(<span class="number">1</span>);<span class="comment">//唤醒进程</span></span><br><span class="line"></span><br><span class="line">    do_hd_request(),</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>do_hd_request算出cyl,head,sector</p></li><li><p>hd_out调用outp(…)完成端口写</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="操作系统" scheme="http://xwdidi.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://xwdidi.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="驱动" scheme="http://xwdidi.com/tags/%E9%A9%B1%E5%8A%A8/"/>
    
      <category term="I/O" scheme="http://xwdidi.com/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>设备驱动与文件系统    L27 键盘</title>
    <link href="http://xwdidi.com/2018/12/30/2018-12-30-L27-%E9%94%AE%E7%9B%98/"/>
    <id>http://xwdidi.com/2018/12/30/2018-12-30-L27-键盘/</id>
    <published>2018-12-29T16:00:00.000Z</published>
    <updated>2019-04-06T13:55:18.446Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前提提要"><a href="#前提提要" class="headerlink" title="前提提要"></a>前提提要</h2><p>设备的驱动,举了例子是显示器.</p><p>显示器是输出,键盘做基础的输入.</p><p>显示器和键盘合在一起是中断设备.</p><h2 id="本章重点"><a href="#本章重点" class="headerlink" title="本章重点"></a>本章重点</h2><h3 id="操作系统是怎么使用键盘的"><a href="#操作系统是怎么使用键盘的" class="headerlink" title="操作系统是怎么使用键盘的."></a>操作系统是怎么使用键盘的.</h3><p><img src="https://i.loli.net/2018/12/29/5c27785716fdb.jpg" alt></p><ol><li>out指令向外设发出命令</li><li>通过文件形成统一的文件视图</li><li>进行中断处理</li></ol><p>本章着重讲<strong>中断处理</strong></p><h3 id="如何使用键盘"><a href="#如何使用键盘" class="headerlink" title="如何使用键盘"></a>如何使用键盘</h3><ol><li><p>对于使用者: 敲键盘,看结果</p></li><li><p>对于OS,”等着”你敲键盘,敲了就中断</p></li><li><p>从键盘中断开始,也就是中断初始化开始.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">con_init</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//应为键盘也是console的一部分</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set_trap_gate(<span class="number">0x21</span>, &amp;ketborad_interrupt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在kerne1/chr drv/keyboard.s中</span></span><br><span class="line">   </span><br><span class="line">.glob1_keyboard_interrupt_keyboard_interrupt:</span><br><span class="line">inb $<span class="number">0x60</span>, %a1<span class="comment">//从端口0x60读扫描吗,从控制器中的缓冲中读出来(ASCII码)</span></span><br><span class="line">   </span><br><span class="line"><span class="function">cal1 <span class="title">key_table</span><span class="params">(,%eax，<span class="number">4</span>)</span><span class="comment">//调用key_table+eax*4根据扫面码决定调用的函数.</span></span></span><br><span class="line"><span class="function">   </span></span><br><span class="line">… push $0 call_do_tty_interrupt</span><br></pre></td></tr></table></figure><p>解析key_table,是函数数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在kernel/chr_drv/keyborad.s中</span></span><br><span class="line"></span><br><span class="line">key_table:</span><br><span class="line">.<span class="keyword">long</span> none,do_self,do_self,do_self<span class="comment">//扫描码00-03,显示字符通常使用此函数进行处理</span></span><br><span class="line">        </span><br><span class="line">.<span class="keyword">long</span> do_self, ... ,func,scroll,cursor 等等<span class="comment">//func是反应f功能键的函数</span></span><br></pre></td></tr></table></figure><p>扫描码02对应对应按键1;01对应esc;12对应E等等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mode:.byte 0</span><br><span class="line">do_self:</span><br><span class="line">lea alt_map,%ebx //找到映射表，如a的key_map映射为a，而shift_map映射为A</span><br><span class="line"></span><br><span class="line">testb $0x20,mode//alt键是否同时按下 </span><br><span class="line"></span><br><span class="line">jne 1f lea_shift_map,%ebx </span><br><span class="line">testb $0x03,mode </span><br><span class="line">jne 1f lea_key_map,%ebx</span><br><span class="line">1：</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://i.loli.net/2018/12/31/5c29eafe4d44b.jpg" alt></p><p>​    通过ebx获得的起始地址和扫描码得到的偏移可写字符的ascii码,并且赋值给al.在放入到缓冲队列中.等进程执行获取队列中的数据. </p><p><img src="![1546251599844](C:\Users\ZJL\AppData\Roaming\Typora\typora-user-images\1546251599844.png" alt></p><p>tty_table[],终端设备使用的函数,</p><p>然后将al输入到队列的头部.</p><h4 id="现在没有回显功能"><a href="#现在没有回显功能" class="headerlink" title="现在没有回显功能."></a>现在没有回显功能.</h4><p><img src="https://i.loli.net/2018/12/31/5c29eefc71b52.jpg" alt></p><p>加工字符,将字符数据写入到显示队列中,然后显示字符.</p><h3 id="键盘的中断处理"><a href="#键盘的中断处理" class="headerlink" title="键盘的中断处理"></a>键盘的中断处理</h3><p><img src="https://i.loli.net/2018/12/31/5c29efd5b9981.jpg" alt></p><p>secondary中的数据才是scanf所需要的字符.</p><p>然后在write_q.显示</p><p><img src="https://i.loli.net/2018/12/31/5c29f091f070e.jpg" alt></p><ol><li>通过系统调用形成的统一的文件视图</li><li>最终落实到out/in指令</li><li>中断处理</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="操作系统" scheme="http://xwdidi.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://xwdidi.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="驱动" scheme="http://xwdidi.com/tags/%E9%A9%B1%E5%8A%A8/"/>
    
      <category term="I/O" scheme="http://xwdidi.com/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>设备驱动与文件系统  L26 I/O与显示器</title>
    <link href="http://xwdidi.com/2018/12/29/2018-12-29-L26-IO%E4%B8%8E%E6%98%BE%E7%A4%BA%E5%99%A8/"/>
    <id>http://xwdidi.com/2018/12/29/2018-12-29-L26-IO与显示器/</id>
    <published>2018-12-28T16:00:00.000Z</published>
    <updated>2019-04-06T13:55:08.706Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前文提要"><a href="#前文提要" class="headerlink" title="前文提要"></a>前文提要</h2><p>操作系统是管理硬件的软件.</p><p><img src="https://i.loli.net/2018/12/29/5c27785716fdb.jpg" alt>)学习得知<code>printf()</code>函数是如何将文字打印到显示屏上的</p><p>I\O设备:键盘和显示器,磁盘,文件系统(驱动磁盘设备)</p><p>##重点知识解析</p><h4 id="如何让外设工作"><a href="#如何让外设工作" class="headerlink" title="如何让外设工作"></a>如何让外设工作</h4><p>CPU发出指令,给显卡or键盘中的寄存器or磁盘控制的寄存器等等写入内容.也就是给相应的寄存器写入东西,通过本身的电路(芯片)进行操控设备.再通过这些设备操作外设.</p><ul><li>发出写命令</li><li>向CPU发出中断</li><li>读数据到内存</li></ul><p>发出核心指令类似这条<code>out xx,a</code>,这样就能让外设工作.外设完事之后,在进行中断的处理</p><ul><li>CPU向控制器中的寄存器读写数据</li><li>控制器完成真正的工作,并向CPU发出中断操作</li></ul><p>外设驱动过程:</p><ol><li><p>out指令(<code>out</code>)</p></li><li><p>外设执行后,要中断处理</p></li><li><p>提供统一的文件视图(接口),不同设备的控制器不一样. (printf)这样方便</p></li></ol><h3 id="一段操纵外设的程序"><a href="#一段操纵外设的程序" class="headerlink" title="一段操纵外设的程序"></a>一段操纵外设的程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"/dev/xxx"</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    write(fd,i,<span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line">close(fd)</span><br></pre></td></tr></table></figure><ol><li>不论什么设备都是open，read，write，close操作系统为用户提供统一的接口!</li><li>不同的设备对应不同的设备文件（（/devlxxx）根据设备文件找到控制器的地址、内容格式等等！</li></ol><p><img src="https://i.loli.net/2018/12/29/5c27805da34f4.jpg" alt></p><p>进行相应处理,根据文件名进行解释,到达控制器作用于实际的外设上,在进行中断处理.</p><h3 id="从操作文件的接口开始-开始给显示器输出"><a href="#从操作文件的接口开始-开始给显示器输出" class="headerlink" title="从操作文件的接口开始,开始给显示器输出"></a>从操作文件的接口开始,开始给显示器输出</h3><ol><li><code>printf(&quot;Host Name: %s&quot;,name)</code></li></ol><ul><li>先创建缓存buf将格式化输出都写到那里，然后write(1，buf.…)[写入显示器]明白<code>write</code>是如何实现的.最终指向<code>out</code>指令.out不同的端口or接口. </li></ul><ol start="2"><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在linux/fs/read write.c中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_write</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd, <span class="keyword">char</span>*buf, <span class="keyword">int</span> count)</span><span class="comment">//fd是file的索引</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span>*<span class="title">file</span>;</span></span><br><span class="line">file=current-&gt;filp[fd]; <span class="comment">//fd = 1,代表这1的地方是一个文件.current代表当前进程</span></span><br><span class="line">    </span><br><span class="line">inode=file-&gt;f_inode;<span class="comment">//取出文件信息(显示器的信息应该就在这里)</span></span><br></pre></td></tr></table></figure><p>1是如何使用的呢.1给fd赋值.</p></li><li><p>fd=1的filp从哪里来？</p><p>因为是被current指向,所以是fork中来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_process</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    *p = *current;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;NR_OPEN;i++)</span><br><span class="line">        <span class="keyword">if</span>((f=p-&gt;filp[i])) f-&gt;f_count++;</span><br></pre></td></tr></table></figure></li></ol><p>这个指针是从父进程继承过来的.</p><p>shel进程启动了whoami命令,shell是其父进程.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(!fork())</span><br><span class="line">&#123;</span><br><span class="line">init();&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    open(<span class="string">"dev/tty0"</span>,O_RDWR,<span class="number">0</span>);dup(<span class="number">0</span>);dup(<span class="number">0</span>);<span class="comment">//dup(0)拷贝两份描述符分别对应1,2.tty0都是终端设备.</span></span><br><span class="line">    </span><br><span class="line">    execve(<span class="string">"/bin/sh"</span>,argv,envp)<span class="comment">// 启动shell代替子进程中的tty0程序</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/dev/tty 代表控制终端</p><p><code>dup()</code>传给该函数一个既有的描述符，返回一个新的描述符，新的描述符是传给它的描述符的拷贝.</p><ol start="4"><li>open系统调用完成了什么呢</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在linux/fs/open.c中,解析目录找到inode</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*filename,<span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">i=open_namei(filename,flag,&amp;inode);<span class="comment">//根据文件名字读入文件</span></span><br><span class="line">    </span><br><span class="line">cuurent-&gt;filp[fd]=f;<span class="comment">//第一个空闲的fd </span></span><br><span class="line">    </span><br><span class="line">f-&gt;f_mode=inode-&gt;i_mode;</span><br><span class="line">f-&gt;f_inode=inode;<span class="comment">//读入inode,有着具体信息.</span></span><br><span class="line">    </span><br><span class="line">f-&gt;f_count=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> fd;&#125;</span><br></pre></td></tr></table></figure><p>核心就是形成这样的一个链</p><p><img src="https://i.loli.net/2018/12/29/5c2789228e507.jpg" alt></p><p>当前的PCB根据链找到dev/tty对应的inode.根据inode找到所指向的设备.</p><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><p>filp中的1由<code>open(&quot;/dev/tty0&quot;)</code>产生.write操作相应的inode写入信息.</p><h4 id="向屏幕输出"><a href="#向屏幕输出" class="headerlink" title="向屏幕输出"></a>向屏幕输出</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在linux/fs/read write.c中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_write</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd,<span class="keyword">char</span>*buf,<span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">inode = file-&gt;f_node;</span><br><span class="line"><span class="keyword">if</span>(S_ISCHR(inode-&gt;i_mode))<span class="comment">//判断是否是char(字符)设备,</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">return</span> rw_char(WRITE,inode-&gt;i_zone[<span class="number">0</span>],buf,cnt);<span class="comment">//通过inode判断是字符的第几个字符设备</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>转入<code>rw_char</code></p><p>在<code>/dev</code>中输入<code>ls -l</code>,能查主设备号和副设备号</p><p>假设主设备号是4.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在linux/fs/char dev.c中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rw_char</span><span class="params">(<span class="keyword">int</span> rw,<span class="keyword">int</span> dev,<span class="keyword">char</span>*buf,<span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">crw_ptr call_addr=crw_table[MAJOR(dev)];<span class="comment">//通过主设备号查表,获得对应的处理函数地址,赋值给函数指针</span></span><br><span class="line">call_addr(rw,dev,buf,cnt);...&#125;</span><br></pre></td></tr></table></figure><h4 id="看看crw-table"><a href="#看看crw-table" class="headerlink" title="看看crw_table"></a>看看<code>crw_table</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> crw_ptr crw_table[]=&#123;…, rw_ttyx,&#125;;<span class="comment">//第四个是rw_ttyx, crw_table函数指针数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> (*crw_ptr)(<span class="keyword">int</span> rw, <span class="keyword">unsigned</span> minor, <span class="keyword">char</span>* buf, <span class="keyword">int</span> count)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rw_ttyx</span><span class="params">(<span class="keyword">int</span> rw, <span class="keyword">unsigned</span> minor, <span class="keyword">char</span>* buf, <span class="keyword">int</span> count)</span><span class="comment">//此时rw==WRITE</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">return</span>((rw==READ) ? tty_read(minor, buf):tty_write(minor, buf));<span class="comment">//写入缓冲</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析tty_write//实现输出的核心</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在1inux/kernel/tty_io.c中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tty_write</span><span class="params">(<span class="keyword">unsigned</span> channel,<span class="keyword">char</span>*buf,<span class="keyword">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span>*<span class="title">tty</span>;</span></span><br><span class="line">    tty=channel+tty_table;</span><br><span class="line">    sleep_if_full(&amp;tty-&gt;write_q); <span class="comment">//可以猜测:输出就是放入队列,满了的话就sleep</span></span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line"><span class="keyword">char</span> c,*b=buf;<span class="comment">//buf在用户态内存,</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(nr&gt;<span class="number">0</span>&amp;&amp;!FULL(tty-&gt;write_q))&#123;</span><br><span class="line">        c = get_fs_byte(b);<span class="comment">//fs从缓冲区读取</span></span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'\r'</span>)&#123;</span><br><span class="line">            PUTCH(<span class="number">13</span>,tty-&gt;write_q);<span class="comment">//放入队列中输出</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(O_LCUC(tty))</span><br><span class="line">            c = <span class="built_in">toupper</span>(c);</span><br><span class="line">        b++;</span><br><span class="line">        nr--;</span><br><span class="line">        PUTCH(c,tty-&gt;tty_write_q);</span><br><span class="line">    &#125;<span class="comment">//输出完事或写队列满</span></span><br><span class="line">    </span><br><span class="line">    tty-&gt;write(tty);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tty-gt-write-tty-真的开始输出屏幕了"><a href="#tty-gt-write-tty-真的开始输出屏幕了" class="headerlink" title="tty-&gt;write(tty)真的开始输出屏幕了."></a><code>tty-&gt;write(tty)</code>真的开始输出屏幕了.</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在include/linux/tty.h中</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span>(*write)(struct tty struct*tty);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty</span> _<span class="title">queue</span> <span class="title">read_q</span>,<span class="title">write_g</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tty中的write函数,再看看tty_struct的初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> <span class="title">tty_table</span>[] = &#123;</span></span><br><span class="line">   &#123;con_write,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">""</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">""</span>&#125;&#125;,&#123;&#125;,...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在看(consle)con_write实施细节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在1inux/kerne1/chr drv/console.c中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">con_write</span><span class="params">(struct tty_struct*tty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GETCH(tty-&gt;write_q,c);</span><br><span class="line"><span class="keyword">if</span>(c&gt;<span class="number">31</span>&amp;&amp;c&lt;<span class="number">127</span>)&#123;</span><br><span class="line">__asm__(<span class="string">"movb _attr,%%ah\n\t"</span>  <span class="comment">//_attr是属性赋值给ah</span></span><br><span class="line">           </span><br><span class="line"><span class="string">"movw %%ax,%1\n\t"</span>::<span class="string">"a"</span>(c),<span class="comment">//字符c赋值给ax的al.ax赋值给%1(pos)\</span></span><br><span class="line">            </span><br><span class="line"><span class="string">"m"</span>(*(<span class="keyword">short</span>*)pos):<span class="string">"ax"</span>);<span class="comment">//pos就是显卡的控制器,ax字符放到显存上. </span></span><br><span class="line">        </span><br><span class="line">     pos+=<span class="number">2</span>;<span class="comment">//写完显存后移,一个字符大小有16位(字符+字符属性).</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从write队列中获取数据,然后使用汇编代码.</p><p><strong>组原中讲过,如果是独立编制的控制器使用<code>out</code>指令,而控制器与内存统一编制时使用<code>mov</code>指令.</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从wirte开始,用到open获取到设备file,再根据file中的inode通过函数表获取到所需要的注册函数,再out出去.</p><p>这就是设备驱动.(</p><p>写设备驱动</p><ol><li>写入核心out指令</li><li>相应的函数注册到表中</li><li>再创建个dev下的文件,与表中函数对应</li></ol><h3 id="mov-pos解析"><a href="#mov-pos解析" class="headerlink" title="mov pos解析"></a><code>mov pos</code>解析</h3><p><img src="https://i.loli.net/2018/12/30/5c28ba6af1b36.jpg" alt></p><p>gotoxy()根据x,y的值和宏定义得到pos的值</p><p><code>0x90000</code>系统启动时,在setup时取出硬件的参数,将光标的位置(显存的位置)放到该地址处.改地址就是pos位置</p><p><img src="https://i.loli.net/2018/12/30/5c28bca8e245e.jpg" alt></p><p><code>mov pos,c</code></p><p><code>out pos,c</code></p><p>再包装成函数,文件</p><ul><li>用到了缓冲技术</li><li>同步机制</li></ul><p>核心就是cpu向控制器发出指令</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="操作系统" scheme="http://xwdidi.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://xwdidi.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="驱动" scheme="http://xwdidi.com/tags/%E9%A9%B1%E5%8A%A8/"/>
    
      <category term="I/O" scheme="http://xwdidi.com/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>誘い   第十一课</title>
    <link href="http://xwdidi.com/2018/12/18/2018-12-18-%E6%97%A5%E8%AF%AD%E5%8D%81%E4%B8%80%E8%AF%BE%E3%83%BC%E8%AA%98%E3%81%84/"/>
    <id>http://xwdidi.com/2018/12/18/2018-12-18-日语十一课ー誘い/</id>
    <published>2018-12-17T16:00:00.000Z</published>
    <updated>2019-04-06T13:55:00.385Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>実は<br>では　失礼します<br>ちょっと    表示省略</p><p>いいですか　か 疑问　<br>いいですよ    　よ 引起注意<br>ううですれ    　れ 表示确定<br>いいです<br><img src="https:\/\/i.loli.net\/2018\/12\/10\/5c0e77c7e6fd2.png" alt></p><p>みせます<br>あらいます<br>教えます　おしえます<br>またれ～</p><p>表达语句:</p><p>道を教えます</p><h3 id="て形"><a href="#て形" class="headerlink" title="て形"></a>て形</h3><p>一类动词:</p><p>話します　はなして</p><p>探します　さがして</p><p>だします　だして</p><p>します　－＞　して</p><p>書きます　かいて</p><p>聞きます　きいて</p><p>あるきます　歩いて</p><p>開きます　開いて</p><p>泳ぎます　泳いて</p><p>ます　－＞いて</p><p>ぎますー＞いで</p><p>買います　買って</p><p>まちます　まって　</p><p>かえります　帰って</p><p>あります　あって</p><p>います　ちます　ります　ー＞　って</p><p>死にます　しんで</p><p>読みます　よんで</p><p>呼びます　読んで</p><p>にます　みます　びます　－＞って</p><p>二类动词：</p><p>起（o ki）きます　起きて</p><p>寝(n e )ます　寝て</p><p>見(m i)ます　みて</p><p>食べ(ta be)ます　食べて</p><p>i ます</p><p>e ます</p><p>三类动词:</p><p>します　して</p><p>来ます　きて</p><p>アルバイトします　アルバイトして</p><p>勉強します　勉強して</p><p>-ますー＞　て</p><p><img src="https:\/\/i.loli.net\/2018\/12\/16\/5c165e3a107e1.jpg" alt></p><p>用语:</p><p>見てください</p><p>聞いてください</p><p>書いてください</p><p>読んでください</p><p>言ってください</p><p>練習をしてください</p><p>形容词修饰动词表示动作的状态</p><p>早く行きます</p><p>安く売ります</p><p>早くれます</p><p>邀请</p><p>Vませんか｜　Vましょう</p><p>コーヒーを飲みませんか</p><p>映画をみませんか</p><p>音楽を聞きませんか　</p><p>観光名所　</p><p>紅葉（もみじ)をみました</p><p>「まず外（そと）で体（からだ）を洗（あら）って、それからお湯の中に入り（はいり）ます」</p><p>常用表达:</p><ul><li><p>A:こーひでも（助词,语气委婉）飲みに行きませんか</p><p>B：いいですね</p><p>本でも読みましょう</p></li><li><p>A:お茶でもにもに行きませんか</p><p>B：いいですね</p></li><li><p>ドライブはご一緒にどうですか</p></li></ul><p>　　食事はご一緒にどうですか</p><p>都合　情况</p><p>温泉　おんせん</p><p>かんこう　観光</p><p>電話　でんわ</p><p>病気　びょうき</p><p>大丈夫　だいじょうぶ</p><p>もみじ　紅葉</p><p>名所　めいしょ</p><p>何時　なんじ</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="日语" scheme="http://xwdidi.com/categories/%E6%97%A5%E8%AF%AD/"/>
    
    
      <category term="日语" scheme="http://xwdidi.com/tags/%E6%97%A5%E8%AF%AD/"/>
    
      <category term="日本" scheme="http://xwdidi.com/tags/%E6%97%A5%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>内存管理    L25 内存换出 Swapout</title>
    <link href="http://xwdidi.com/2018/12/04/2018-12-04-L25%E5%86%85%E5%AD%98%E6%8D%A2%E5%87%BA/"/>
    <id>http://xwdidi.com/2018/12/04/2018-12-04-L25内存换出/</id>
    <published>2018-12-03T16:00:00.000Z</published>
    <updated>2019-04-06T13:54:36.261Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>换入换出是合在一起进行的.</p><p>换入的目的,实现虚拟内存. 有换入就必须有换出,只有换出空出的新的空闲区域,才能放入新的数据.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>主要讲算法.</p><blockquote><p>有换入就应该有换出</p></blockquote><p><code>page = get_free_page();</code></p><p><code>bread_page(page,current-&gt;excutable-&gt;i_dev,nr)</code></p><p>并不能粽是获得新的页,内存也是有限的</p><ul><li><h3 id="需要选择一页淘汰-换出到磁盘-选择哪一页-尝试"><a href="#需要选择一页淘汰-换出到磁盘-选择哪一页-尝试" class="headerlink" title="需要选择一页淘汰,换出到磁盘,选择哪一页?尝试"></a>需要选择一页淘汰,换出到磁盘,选择哪一页?尝试</h3></li></ul><h3 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h3><h4 id="1-FIFO"><a href="#1-FIFO" class="headerlink" title="1. FIFO"></a>1. FIFO</h4><p>FIFO(先入先出)页面置换.</p><p>实例介绍:分配了3个页框</p><p>每个页换入换出都不合时宜,太过于机械,大多数时间都浪费在I/O中.</p><p>缺页次数应该少.判断使用次数,最少的换出去.</p><p><img src="https://i.loli.net/2018/12/04/5c0688cbad61e.jpg" alt></p><p>产生七次缺页</p><h4 id="2-MIN算法："><a href="#2-MIN算法：" class="headerlink" title="2. MIN算法："></a>2. MIN算法：</h4><p>选最远将使用的页淘汰，是最优方案</p><p><img src="https://i.loli.net/2018/12/04/5c06867d65d76.jpg" alt></p><p>五次换页,</p><p>MIN需要知道将来发生的事…怎么办.</p><h3 id="3-LRU"><a href="#3-LRU" class="headerlink" title="3. LRU"></a>3. LRU</h3><p>least recent use 最近最少使用</p><p>用过去的历史预测将来/</p><p>选取最近最长一段时间没有使用的页淘汰(最近最少使用的页)</p><p>程序具有局部性的特点,这样算法会有较大的适应性</p><p> <img src="https://i.loli.net/2018/12/05/5c0795020db27.png" alt="1544000727828"></p><p>### </p><h3 id="1-LRU的准确实现-使用时间戳"><a href="#1-LRU的准确实现-使用时间戳" class="headerlink" title="1. LRU的准确实现,使用时间戳"></a>1. LRU的准确实现,使用时间戳</h3><p>通过对使用的页,每次使用时,增加时间戳.时间戳上显示使用该页的最后时间 .</p><p>若要进行换页选择时间戳最小的页换出.</p><p>根据查出来的逻辑页,需要去维护时间戳.每执行一条指令(取址执行),修改每个页的时间戳.同时要处理.时间戳存在溢出的危险,</p><p><img src="https://i.loli.net/2018/12/05/5c079b48f15a3.jpg" alt></p><blockquote><p>每次地址访问都需要修改时间戳，需维护一个全局时钟，需找到最小值..实现代价较大</p></blockquote><h3 id="2-若采用页码查找"><a href="#2-若采用页码查找" class="headerlink" title="2. 若采用页码查找"></a>2. 若采用页码查找</h3><p>在栈的顶部总是保留最近使用的页.</p><p>换页时,选择栈底页淘汰. </p><p><img src="https://i.loli.net/2018/12/05/5c079d2a0d887.jpg" alt></p><h3 id="3-LRU近似实现-将时间计数变为是和否"><a href="#3-LRU近似实现-将时间计数变为是和否" class="headerlink" title="3. LRU近似实现-将时间计数变为是和否"></a>3. LRU近似实现-将时间计数变为是和否</h3><p>不做时间戳,进计数,</p><ul><li><p>在每个页加一个引用位,访问过这一页这个数置为1</p></li><li><p>二次机会算法.Clock Algorithm</p><p><img src="https://i.loli.net/2018/12/05/5c07a570759d5.jpg" alt></p><p>进行扫描,访问过的位的数若为1,则置为0,不淘汰.</p><p>如果遇到0时,则被淘汰.  </p><p>1代表最近访问过, 而如果之前再次扫描到被置为0的那个页,则代表了在扫描的时间内没有被访问,则被替换出去.</p><p>为什么说是近似实现呢,最近没有使用是最近最少使用的近似.</p><p>只需要修改一个数,能减少操作数.因为要查页表,MMU直接自动的把R置成1，R可以直接放到页表项中，MMU自动做，不用去维护复杂的数据结构。</p></li></ul><h4 id="Clock算法的分析与改造"><a href="#Clock算法的分析与改造" class="headerlink" title="Clock算法的分析与改造"></a>Clock算法的分析与改造</h4><p>效率高，代价小。</p><p>然而: 如果缺页很少，会</p><p>导致很少从1置为0,会被一直访问,R全为1.如果全为1,扫描后全变为0,一圈后则会将初始的那页换出去,指针指向下一个.下一个与前面的过程相同,然后被换出.算法就变为了按顺序换出,不就是FIFO吗?</p><p>R记录了太长的历史信息,退化为FIFO.所以我们定时清除R位.再来个扫描指针</p><p><img src="https://i.loli.net/2018/12/05/5c07ac294d762.jpg" alt></p><p>缺页导致指针转的太慢,用扫描指针清零.被清零后又没被使用,仍然为0,则他会被调出.</p><h4 id="那么该给进程分配多少页框呢-物理内存"><a href="#那么该给进程分配多少页框呢-物理内存" class="headerlink" title="那么该给进程分配多少页框呢(物理内存)"></a>那么该给进程分配多少页框呢(物理内存)</h4><ul><li><p>分配过多,请求调页导致的内存高效就没了.</p></li><li><p>分配太少呢?<img src="https://i.loli.net/2018/12/05/5c07ad64b5d0f.jpg" alt></p><p>这一现象被称为颠簸.</p><p>原因解释：</p><p><strong>系统内进程增多&gt;每个进程的缺页率增大&gt;缺页率增大到一定程度，进程总等待调页完成&gt;</strong><br><strong>CPU利用率降低&gt;进程进一步增多，缺页率更大…</strong></p></li></ul><p>所以分配的局部,需要覆盖一个局部(通过某种算法求得的”工作集”),也可以通过动态调整页框数量,减少颠簸.</p><p>如果进程太多,无法囊括全部.需要限制进程数量,涉及CPU管理,进程管理.</p><p>clock环形数组+clock算法.</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>换入缺页,从磁盘读入一个页,可能没有足够的页大小,则使用clock算法换出一个页,再将页换入.这就是swap分区管理.</p><p>内存,时钟中断,磁盘管理,磁盘驱动.实现了换入换出的模型.又是为了实现虚拟内存,又是为了实现段页管理,又实现操作系统内存管理,又是为了实现程序的正常加载,又实现了进程.</p><p>形成了以进程带动的多进程推进,内存有效管理的图.初始化,系统接口,设备驱动,文件系统实现了基本简单完整的操作系统.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="操作系统" scheme="http://xwdidi.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://xwdidi.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="汇编语言" scheme="http://xwdidi.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
      <category term="内存" scheme="http://xwdidi.com/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>季節と天気   第十课</title>
    <link href="http://xwdidi.com/2018/12/03/2018-12-03-%E6%97%A5%E8%AF%AD%E7%AC%AC%E5%8D%81%E8%AF%BE/"/>
    <id>http://xwdidi.com/2018/12/03/2018-12-03-日语第十课/</id>
    <published>2018-12-02T16:00:00.000Z</published>
    <updated>2019-04-06T13:54:22.903Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>きせつ　季節</p><p>しき    四季</p><p>春　はる　　</p><p>夏    なつ</p><p>秋    あき</p><p>冬    ふゆ</p><p>天気　てんき</p><p>あたたかい　暖かい</p><p>あつい　あつい</p><p>闷热     蒸し暑い　むしあつい</p><p>涼しい　すずしい</p><p>さむい　寒い</p><p>あめ　雨</p><p>雨が降ります</p><p>ゆき</p><p>雪が降ります</p><p>風</p><p>風が吹きます</p><p>さくらが咲きます</p><p>花見をします　赏花</p><p>海　うみ</p><p>すいえい　水泳</p><p>私は海が好きです</p><p>花火　はなび</p><p>紅葉をみます</p><p>スキー　滑雪</p><p>スキー場　すきーじょう</p><p>四季がはっきりあります　　</p><p>はっきり　 清楚</p><p>梅雨　つゆ</p><p>台風　たいふう</p><p>洪水　こうずい</p><p>地震　じしん</p><p>津波　つなみ　海啸</p><p>私は日本</p><p>羨ましなあ</p><p>いや　</p><p>梅雨は嫌です</p><p>楽しい　たのしい</p><p>じゅう　</p><p>一年中　いちねんじゅう</p><p>日本中　にほんじゅう</p><p>今日中　きょじゅう</p><p>島国　しまぐに</p><p>北海道　ほっかいどう</p><p>札幌　さっぽろ</p><p>仙台　せんだい</p><p>東京　とうきょう</p><p>名古屋　なごや</p><p>京都　きょうと</p><p>おおさか　大阪</p><p>神戸　こうべ</p><p>広島　ひろしま</p><p>四国　しこく</p><p>きゅうしゅう　九州</p><p>福岡　ふくおか</p><p>沖縄　おきなわ</p><p>Aかったです　い变为かった</p><p>寒い　寒かった　寒かったです</p><p>可愛い　可愛かった　可愛かったです</p><p>いい    よかった</p><p>昨日は暖かったです　　　　　<br>昨日は暑かったです。　　<br>昨日はさむかったです、きょうはさむくないです</p><p>Aくなかったです　否定</p><p>寒くないです</p><p>寒くなかったです　过去否定</p><p>寒くありません</p><p>寒くありませんでした</p><p>昔　以前</p><p>昨日は寒かったです、今日も寒いです。</p><p>二类形容词</p><p>ANでした/ANではありませんでした</p><p>李さんはコーヒーがきらいでした</p><p>静か　ふべん　きれい</p><p>前のアパートは静かでした。ふべんでした。きれいではありませんでした</p><p>形容词表示变化</p><p>Aく／ANに　＋　なります</p><p>１．　～くなります    寒くなります    今日は暖かくなりました。</p><p>２．　けれいになりました</p><p>形容词并列</p><p>Aくて／ANで</p><p>～～Aくて</p><p>１．</p><p>安くて美味しいです</p><p>ひるは暑くて、よるは寒いです</p><p>２．</p><p>このアパートは静かで便利です</p><p>図書館はしずかで、公園はにぎやかです</p><p>修饰名词</p><p>AいN／ANなN</p><p>広い部屋</p><p>面白い映画を見ました</p><p>美味しい日本料理をたべました。</p><p>静かな町</p><p>有名な大学</p><p>綺麗な桜をみました</p><p><img src="https://i.loli.net/2018/12/03/5c052db339238.png" alt></p><p>今度　こんど</p><p>うらやましいなあ</p><p>裏日本</p><p>表日本</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="日语" scheme="http://xwdidi.com/categories/%E6%97%A5%E8%AF%AD/"/>
    
    
      <category term="日语" scheme="http://xwdidi.com/tags/%E6%97%A5%E8%AF%AD/"/>
    
      <category term="日本" scheme="http://xwdidi.com/tags/%E6%97%A5%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>内存管理    L24 内存换入-请求调页</title>
    <link href="http://xwdidi.com/2018/11/27/2018-11-27-L24%E5%86%85%E5%AD%98%E6%8D%A2%E5%85%A5-%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5/"/>
    <id>http://xwdidi.com/2018/11/27/2018-11-27-L24内存换入-请求调页/</id>
    <published>2018-11-26T16:00:00.000Z</published>
    <updated>2019-04-06T13:54:13.166Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="回顾与引导"><a href="#回顾与引导" class="headerlink" title="回顾与引导"></a>回顾与引导</h2><p>内存换出是从虚拟内存中引申出来的.</p><p>为什么需要虚拟内存呢,实现段页式,用虚拟内存进行分段,将虚拟内存分成一页一页的映射到物理内存中.</p><p>虚拟内存是连接分页分段的核心所在,分段分页管理内存的重要机制,换入换出是实现虚拟内存的关键.</p><p>分段,让用户使用.分页,提高内存效率.虚拟内存做中介.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基于虚拟内存的分段分页.换入换出机制实现虚拟内存. </p><p>段页同时存在时就拥有虚拟内存,用户程序只看到了0-4g的虚拟内存地址.割出内存存放,然后完成映射.</p><p>用户可以随意的使用这4个g的虚拟内存,就像拥有4g内存.用户程序是不知道如何映射的.</p><h4 id="用换入-换出实现”大内存”"><a href="#用换入-换出实现”大内存”" class="headerlink" title="用换入,换出实现”大内存”"></a>用换入,换出实现”大内存”</h4><p>4g虚拟内存是可能无法全部装入物理内存中的.</p><p>例:虚拟内存4g,物理内存1g.<br>换入换出,只有需要使用的内存地址,才进入物理内存中,其他数据暂时存储在物理磁盘上.等需要使用时再进行交换.</p><p>虚拟内存相当于仓库,物理内存相当于店面,从仓库拿出所需物品放到柜台上.(大概这个意思吧</p><p><strong>请求的时候才做映射</strong></p><h4 id="请求调页"><a href="#请求调页" class="headerlink" title="请求调页"></a>请求调页</h4><p>请求调入页面-&gt;建立映射.</p><ul><li>逻辑地址中的0-4g随意的虚拟地址,  然后访问段表得到虚拟内存地址.当虚拟地址真正的去映射的时候, 如果不存在映射的话(缺页),需要请求进行调页.</li></ul><p>执行地址,MMU发现<strong>缺页</strong>的时候,会发生中断.进行页错误处处理程序. 通过相关算法,找到磁盘中所需的页,并在空闲内存(<code>get_free_page()</code>)处进行映射. (换页)然后在执行中断前的指令.相当于对用户透明.</p><p>图一:<img src="https://i.loli.net/2018/11/28/5bfe8f718ebb8.jpg" alt></p><p>Q:采用请求调页不采用请求调段的原因是什么呢.</p><p>​    大概 (请求调页的粒度更细，更能提高内存效率)</p><p> 实现了虚拟内存的概念,</p><h3 id="实际的请求调页"><a href="#实际的请求调页" class="headerlink" title="实际的请求调页"></a>实际的请求调页</h3><ol><li><p>从哪里开始呢?</p><p>(1)是MMU硬件所做的,我们可以在缺页的中断开始.</p><p><img src="https://i.loli.net/2018/11/28/5bfe9181cf1b0.jpg" alt></p><p>设置好中断后怎么处理.</p><p>一下时处理程序的详细解析.</p><ol><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;set_trap_gate(<span class="number">14</span>,spage_fault);&#125;<span class="comment">//设置14号中断</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_trap_gate(n,addr)\</span></span><br><span class="line">_set_gate(&amp;idt[n],<span class="number">15</span>,<span class="number">0</span>,addr);</span><br></pre></td></tr></table></figure></li><li><p>处理中断page fault</p><p><img src="https://i.loli.net/2018/11/28/5bfe92454bd29.jpg" alt></p><p>上面是内核代码段,错误信息的线性地址(虚拟地址)在cr2中,并复制给edx.</p><p>并且压栈,调用相关处理函数. </p><p><img src="https://i.loli.net/2018/11/28/5bfe937cd0f69.jpg" alt></p></li><li><p>do_no_page(解析</p><p>调页具体操作.读磁盘,申请空闲内存,</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在1inux/mm/memory.c中</span></span><br><span class="line">void do_no_page()unsigned long error_code,unsigned long address)</span><br><span class="line">&#123;</span><br><span class="line">address&amp;=<span class="number">0xfffff000</span>;<span class="comment">//页面地址,得到偏移地址</span></span><br><span class="line">    </span><br><span class="line">tmp=address-current-&gt;start code;<span class="comment">//页面对应的偏移</span></span><br><span class="line"><span class="keyword">if</span>(!current-&gt;executablel||tmp&gt;=current-&gt;end_data)&#123;<span class="comment">//不是代码和数据</span></span><br><span class="line">        </span><br><span class="line">get_empty_page()address);<span class="keyword">return</span>;&#125;</span><br><span class="line">page=get_free_page());<span class="comment">//获得空闲内存</span></span><br><span class="line">    </span><br><span class="line">bread_page(page,current-&gt;executable-&gt;i_dev,np);<span class="comment">// (blockread)磁盘读写,从这个设备中读写.</span></span><br><span class="line">    </span><br><span class="line">put_page(page,address);<span class="comment">//建立映射</span></span><br></pre></td></tr></table></figure><ul><li>中断</li><li>申请空闲页</li><li>读入需要页</li><li>建立映射</li><li>中断返回执行中断前的地址.</li></ul><p><img src="https://i.loli.net/2018/11/28/5bfe984d393c6.jpg" alt></p><ol start="4"><li>put_page解析</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在1inux/mm/memory.c中</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="number">1</span><span class="function">ong put <span class="title">page</span><span class="params">(<span class="keyword">unsigned</span> <span class="number">1</span>ong page，<span class="comment">//物理地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">                       </span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function">                       </span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">unsigned</span> <span class="keyword">long</span> tmp，*page table;page_table=(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)((address&gt;&gt;<span class="number">20</span>)&amp;ffc);<span class="comment">//页目录项</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(*page table)&amp;<span class="number">1</span>)</span><br><span class="line">page_table=(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(Oxfffff000&amp;*page_table);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">tmp=get_free_page();</span><br><span class="line">*page_table=tmpl7; page_table=(<span class="keyword">unsigned</span> <span class="number">1</span>ong*)tmp;&#125;</span><br><span class="line">page_table[(address&gt;&gt;<span class="number">12</span>)&amp;<span class="number">0x3ff</span>]=pagel7; <span class="keyword">return</span> page;</span><br><span class="line">&#125;<span class="comment">//放入page_table上</span></span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>实现页面的换入,实现请求调页,无非就是中断处理(申请空闲也,读入需要页,建立映射),如果没有相关页,则进行中断处理.</p></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="操作系统" scheme="http://xwdidi.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://xwdidi.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="汇编语言" scheme="http://xwdidi.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
      <category term="内存" scheme="http://xwdidi.com/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>アパート    第九课</title>
    <link href="http://xwdidi.com/2018/11/25/2018-11-25-%E6%97%A5%E8%AF%AD%E7%AC%AC%E4%B9%9D%E8%AF%BE/"/>
    <id>http://xwdidi.com/2018/11/25/2018-11-25-日语第九课/</id>
    <published>2018-11-24T16:00:00.000Z</published>
    <updated>2019-04-06T13:54:02.907Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>イ类<br>安い　やすい</p><p>高い　たかい</p><p>低い　ひくい    </p><p>近い    　ちかい</p><p>遠い    　とおい    </p><p>新しい　あたたしい</p><p>古い　ふるい</p><p>大きい　おおきい</p><p>小さい　ちいさい</p><p>多い        おおい<br>少ない　すくない</p><p>難しい　むずかしい</p><p>易しい　やさしい</p><p>美味しい　おいしい</p><p>かわいい　可愛い</p><p>いい　よい</p><p>二类</p><p>しずか　静か</p><p>賑やか　にぎやか</p><p>便利　べんり</p><p>不便　ふべん</p><p>上手　じょうず</p><p>下手　へた</p><p>立派　りっぱ</p><p>複雑　ふくざつ</p><p>必要　ひつよう</p><p>ゆうめい　有名</p><p>綺麗　きれい</p><p>探します　さがします</p><p>選びます　えらびます</p><p>見ます　みます</p><p>きめます　決めます</p><p>払いまし　はらいます</p><p>家賃　やちん</p><p>ふどうさん　不動産</p><p>不動産会社</p><p>手続き　てつづき</p><p>保証人　ほしょにん</p><p>くるま　車</p><p>敷金　しききん</p><p>いい\よい</p><p>いい　よっくないです</p><p>いい　よくありません</p><p>I类否定:</p><p>く　＋　ありません</p><p>く　＋　ないです</p><p>II类否定:</p><p>は。。＋ではありません</p><p>ｘｘｘｘ　よりA／ANです</p><p>…(主语)は…よりA／ANです　より是前面的名词表示基准</p><p>..より…がA/ANです</p><p>Q：。。と・・と　どちらがA/ANですか　と表示并列</p><p>A:。。のほうがA/ANです　</p><p>…に近いです</p><p>。。。（起点）から遠いです</p><p>どぞう</p><p>日当たり　向阳处</p><p>昨日　きのう</p><p>きょう    　今日</p><p>最後　さいご</p><p>てつづき　手続き</p><p>保証人　ほしょうにん</p><p>素晴らしい　すばらしい</p><p>お住まい　おすまい</p><p>　飾り　かざり</p><p>上品　じょうひん</p><p>センス　</p><p>いいえ　とんでもありません</p><p>アパート　</p><p>和室　わしつ</p><p>襖　ふすま</p><p>押入　おしいれ</p><p>玄関　げんかん</p><p>洋室　ようしつ</p><p>マンション    n(数量)l(起居室)d(客厅)k(厨房)</p><p>アパート　一层或两层 木制</p><p>紹介　しょうかい</p><p>ふろ　</p><p>建物　たてもの</p><p>食堂　しょくどう</p><p>は　衬托主语</p><p>が　    谓语</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="日语" scheme="http://xwdidi.com/categories/%E6%97%A5%E8%AF%AD/"/>
    
    
      <category term="日语" scheme="http://xwdidi.com/tags/%E6%97%A5%E8%AF%AD/"/>
    
      <category term="日本" scheme="http://xwdidi.com/tags/%E6%97%A5%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>内存管理      L23   段页结合的实际内存管理</title>
    <link href="http://xwdidi.com/2018/11/24/2018-11-24-L23%E6%AE%B5%E9%A1%B5%E7%BB%93%E5%90%88%E7%9A%84%E5%AE%9E%E9%99%85%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://xwdidi.com/2018/11/24/2018-11-24-L23段页结合的实际内存管理/</id>
    <published>2018-11-23T16:00:00.000Z</published>
    <updated>2019-04-06T13:53:47.804Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>操作系统分段分页管理内存.</p><p>用户程序分段管理.</p><p>物理内存采用分页机制有效利用内存.</p><h2 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h2><h3 id="如何结合在一起"><a href="#如何结合在一起" class="headerlink" title="如何结合在一起"></a>如何结合在一起</h3><h4 id="分段"><a href="#分段" class="headerlink" title="分段:"></a>分段:</h4><p>在虚拟内存中分区,割出区域;用户程序分段,然后建立映射关系.</p><h4 id="分页"><a href="#分页" class="headerlink" title="分页:"></a>分页:</h4><p>物理内存打散成固定大小的页,用户程序打散成页,映射到各个页上面.</p><h4 id="想法"><a href="#想法" class="headerlink" title="想法:"></a>想法:</h4><p>将分段后的内存分布与被打散成页的用户程序进行关联.</p><p>如何将二者进行等价呢.?</p><p>将虚拟内存中分好段的程序映射给分好页的物理内存上,应该可行.</p><p>内存即地址空间.割出一段地址,给用户程序中的段,再从虚拟(内存)地址空间上映射给物理内存页上.</p><p>虚拟内存是不能真正使用的.</p><h3 id="段、页同时存在：段面向用户-页面向硬件"><a href="#段、页同时存在：段面向用户-页面向硬件" class="headerlink" title="段、页同时存在：段面向用户/页面向硬件"></a>段、页同时存在：段面向用户/页面向硬件</h3><ol><li><p>虚拟内存上割出一个段存放应用程序(被隔离).然后操作系统将地址映射到物理内存上.</p><p><img src="https://i.loli.net/2018/11/23/5bf80f1a1829e.jpg" alt></p></li><li><p>隔离内存是为了让用户<strong>使用内存</strong>.</p><p>段页同时存在时的<strong>重定位</strong>(地址翻译).</p><ul><li><p>根据段表寻找基址,得到虚拟地址</p></li><li><p>操作系统根据页表得到页号和偏移地址形成物理地址.</p><p><img src="https://i.loli.net/2018/11/23/5bf8121d8754e.jpg" alt></p><p>例:<code>jmp 40</code></p><p>通过两层地址翻译到达物理地址. </p></li></ul><p>既支持了段,又支持了页.</p><p>做好实验6,实际的段页内存管理.</p><p>核心在于:逻辑地址-&gt;虚拟地址-&gt;物理地址.(两层映射).</p></li></ol><h3 id="一个实际的段、页式内存管理"><a href="#一个实际的段、页式内存管理" class="headerlink" title="一个实际的段、页式内存管理"></a>一个实际的段、页式内存管理</h3><p>内存管理核心就是内存分配，所以从程序放入内存、使用内存开始..</p><p>要给进程分配内存,</p><ul><li><p>分配段,建段表;分配页,建页表</p></li><li><p>进程带动内存使用的图谱</p></li><li><p>从进程<strong>fork</strong>中的内存分配开始,从到能使用内存结束</p><ul><li><p>如何载入内存呢?</p><p>将用户段和虚拟内存割出的区域进行关联,建立映射(段表). 分区适配算法.</p><p>再将这段区域割成小块,每块和物理页的页框关联在一起.</p><p>最终表现为数据的物理内存存放.</p></li><li><p>具体点:使用段表记录虚拟内存区域的记录,页表记录虚拟内存区域如何放到物理内存上.</p><p><img src="https://i.loli.net/2018/11/24/5bf911d550baa.jpg" alt></p></li></ul><p>例:<code>[300]</code>如何寻址呢.</p><p>查询段表得到<code>ds:300</code>,然后<code>0x000453000</code>查表得到页表和页框号,最后得到了<code>0x7300</code>. </p><ol><li>割一段区域</li><li>程序到虚拟内存中</li><li>物理内存寻找空闲页</li><li>建立页表,错判载入</li><li>能使用300地址</li></ol></li></ul><h4 id="1-从fork开始-分配虚存-建段表"><a href="#1-从fork开始-分配虚存-建段表" class="headerlink" title="1. 从fork开始 分配虚存,建段表"></a>1. 从fork开始 <strong>分配虚存,建段表</strong></h4><p>fork()-&gt;sys_fork-&gt;copy_process</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_process</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">long</span> ebp,..)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    copy_mem(nr,p);...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>copy_mem</code>解析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_mem</span><span class="params">(<span class="keyword">int</span> nr,task_struct *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> new_data_base; </span><br><span class="line">new_data_base=nr*<span class="number">0x4000000</span>;<span class="comment">//64M*nr (nr是代表第几个进程) 对虚拟内存的分割,割了64m,放入代码段数据段. ①</span></span><br><span class="line">    </span><br><span class="line">set_base(p-&gt;<span class="number">1</span>dt[<span class="number">1</span>],<span class="keyword">new</span> data base);<span class="comment">//设置基址,填写段表 ②</span></span><br><span class="line">    </span><br><span class="line">set_base(p-&gt;<span class="number">1</span>dt[<span class="number">2</span>],<span class="keyword">new</span> data base);<span class="comment">//进程切换 pcb指向的段表会跟着切换</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/11/24/5bf91ebfc60d3.jpg" alt></p><ul><li><p>代码段,数据段都是一个段.</p></li><li><p>每个进程占64M虚拟地址空间，<strong>互不重叠</strong></p></li></ul><h4 id="虚拟地址与物理内存进行映射"><a href="#虚拟地址与物理内存进行映射" class="headerlink" title="虚拟地址与物理内存进行映射."></a>虚拟地址与物理内存进行映射.</h4><p>虚拟地址不重叠,所以分成的页也不会重叠.所以能共用一套页表.(简化的方法)</p><h4 id="2-接下来做什么呢-分配内存-建段表"><a href="#2-接下来做什么呢-分配内存-建段表" class="headerlink" title="2. 接下来做什么呢 ,分配内存,建段表"></a>2. 接下来做什么呢 ,分配内存,建段表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_mem</span><span class="params">(<span class="keyword">int</span> nr,task struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">unsigned</span> <span class="keyword">long</span> old_data_base; </span><br><span class="line">old_data_base=get_base(current-&gt;<span class="number">1</span>dt[<span class="number">2</span>]); </span><br><span class="line">    <span class="function">copy page <span class="title">tables</span><span class="params">(old_data_base,new_data_base,data_limit)</span></span>;<span class="comment">//赋值页表, 共用一套页表,根据虚拟地址进行页表的拷贝</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_page_tables</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> from,<span class="keyword">unsigned</span> <span class="keyword">long</span> to,<span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">from_dir =(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(from&gt;&gt;<span class="number">20</span>)&amp;<span class="number">0xffc</span>);<span class="comment">//右移20位,父进程的虚拟地址,原因看图</span></span><br><span class="line">    </span><br><span class="line">to_dir=(<span class="keyword">unsigned</span> <span class="number">1</span>ong*)(to&gt;&gt;<span class="number">20</span>)&amp;<span class="number">0xffc</span>);</span><br><span class="line">size=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size+Ox3fffff)&gt;&gt;<span class="number">22</span>;</span><br><span class="line"><span class="keyword">for</span>(;size--&gt;<span class="number">0</span>;from_dir++,to dir++)&#123;</span><br><span class="line">from_page_table=(OXfffff000&amp;*from_dir);</span><br><span class="line">to_page_table=get_free_page();</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/11/24/5bf924690ca5b.jpg" alt></p><p>为什么不右移22位呢,右移22位后乘以4,4是指针的大小.</p><h3 id="from-page-table-与to-page-table？"><a href="#from-page-table-与to-page-table？" class="headerlink" title="from_page_table 与to_page_table？"></a>from_page_table 与to_page_table？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;size--&gt;<span class="number">0</span>;from_dir++,to_dir++)&#123;</span><br><span class="line">to_page_table=get_free)page();</span><br><span class="line">    *to_dir = ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)to_page_table) | <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>根据页框指针寻找真正的页框号.</p><p>to_dir是子进程的页目录.父进程的页目录已经指向分配好的内存.子进程要指向合适的内存页了,通过<code>get_free_page()</code>获得空闲内存页以便于分配.用的时候再建立映射,节约了内存空间.再将分配好的地址赋值给<code>to_dir</code>.</p><h5 id="get-free-page-解析"><a href="#get-free-page-解析" class="headerlink" title="get_free_page()解析"></a>get_free_page()解析<img src="https://i.loli.net/2018/11/24/5bf928141e063.jpg" alt></h5><h4 id="3-完成内存的拷贝"><a href="#3-完成内存的拷贝" class="headerlink" title="3. 完成内存的拷贝."></a>3. 完成内存的拷贝.</h4><p>父进程指向的地方,子进程也需要指向它.</p><p><img src="https://i.loli.net/2018/11/24/5bf929f90e7a0.jpg" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>（；nr--&gt;<span class="number">0</span>；from_page_table++，to_page_table++）&#123;</span><br><span class="line">this_page=*from_page_table;</span><br><span class="line">    this_page&amp;=~<span class="number">2</span>; <span class="comment">// 只读写时复制</span></span><br><span class="line">    </span><br><span class="line">    *to_page_table = this_page;</span><br><span class="line">    *from_page_table=this_page;</span><br><span class="line">this_page-=LOW_MEM; this_page &gt;&gt;=<span class="number">12</span>;</span><br><span class="line">mem_map[this_page]++;<span class="comment">//作+1标记,多者共用内存空间,一个进程释放-1,直到0占用内存才被释放 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="4-程序-虚拟内-物理内存的模样"><a href="#4-程序-虚拟内-物理内存的模样" class="headerlink" title="4. 程序 虚拟内+物理内存的模样"></a>4. 程序 虚拟内+物理内存的模样</h3><p><img src="https://i.loli.net/2018/11/24/5bf92ca5ca970.jpg" alt></p><p>进程1<code>fork()</code>后形成进程2.</p><h3 id="5-放完后-如何使用呢"><a href="#5-放完后-如何使用呢" class="headerlink" title="5. 放完后,如何使用呢"></a>5. 放完后,如何使用呢</h3><p>段(LDT)表和页表建立好后,执行指令时MMU自动计算.</p><p>以下是大概流程.<code>*p = 7</code></p><p><img src="https://i.loli.net/2018/11/24/5bf92e9f0bf81.jpg" alt></p><p>fork后的进程二,因为原p的地址被设为只读了,为了避免其影响进程1,则会修改页表,再次申请一片新的内存,形成新的映射关系.</p><blockquote><p>进程拉动了内存</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="操作系统" scheme="http://xwdidi.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://xwdidi.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="汇编" scheme="http://xwdidi.com/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="内存" scheme="http://xwdidi.com/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>内存管理   L22 多级页表与快表</title>
    <link href="http://xwdidi.com/2018/11/19/2018-11-19-L22%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E4%B8%8E%E5%BF%AB%E8%A1%A8/"/>
    <id>http://xwdidi.com/2018/11/19/2018-11-19-L22多级页表与快表/</id>
    <published>2018-11-18T16:00:00.000Z</published>
    <updated>2019-04-06T13:53:37.588Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>分页机制,物理系统变为一片一片固定大小的页,内存碎片少,空间利用率高.</p><p>单独分页机制的问题通过多级页表与快表解决.三个合在一起才能在基本的操作系统中运行.</p><h2 id="课程重点总结"><a href="#课程重点总结" class="headerlink" title="课程重点总结"></a>课程重点总结</h2><p>提高空间利用率,页小了,页表就大了.</p><p><img src="https://i.loli.net/2018/11/19/5bf2afea63309.jpg" alt></p><p>页表为什么会大呢,每页小了,页表项会增加.逻辑页号多了,(逻辑页号 = 地址(寻址范围0-4GB)/页大小).<code>jmp 40</code>40/100 = 0,第0页(逻辑页号),得到内存中的页框号(物理内存页).页表大了,浪费的多了,所以也应该小一点.太小了,也会导致页表项过大.</p><h4 id="页表会很大，页表放置就成了问题…"><a href="#页表会很大，页表放置就成了问题…" class="headerlink" title="页表会很大，页表放置就成了问题…"></a>页表会很大，页表放置就成了问题…</h4><ol><li><p>页面尺寸通常为4K，而地址是32位的，有2^20个页面,需要4m内存,系统中并发是个进程,就需要40M内存.对于内存消耗过大,过于浪费.32位最多调用4个G.</p><p>实际上大部分逻辑地址根本不会用到.</p></li><li><p>如何减少表的大小呢:</p><ol><li>只存放用到的页.</li></ol><ul><li><p>某一段地址没被使用,就从特表中删除.<b>用到的逻辑页才有页表项</b>.</p><p>不连续,需要遍历查找.时间复杂度太高.通过二分法查找有较大的速度提升,(通过总线访问内存,会降低CPU速率).会降低CPU速率不建议使用.</p></li><li><p>页号连续,只需要通过偏移地址就能快速定位.(32位地址空间+4K页面+页号必须连续&gt;220个页表项&gt;大页表占用内存，造成浪费.)</p></li><li><p>既要连续又要让页表占用内在少，如何做呢?参考书的章节目录和节目录来类比思考.</p></li></ul><ol start="2"><li>多级页表.</li></ol><ul><li><p>分成不同”章节”,根据需要章节可以跳过不需要的章节.也就是不需要的东西不放到内存中.</p><p>多级页表，即页目录表 + 页表 <img src="https://i.loli.net/2018/11/19/5bf2c6f37b09c.jpg" alt></p><p>32位地址,一页4k.</p><p>页目录项中中间是空白的,仍占据位置以保持连续.2^10-&gt;2^10.每个页表项有2^10个,一页4kb,一个页目录项能指向了4M的空间.可以说这个程序(这个段)使用了12M的内存.在页目录项中,2^10个目录项x4字节地址 = 4k, 此时只占用4kx(3+1)= 16k的空间.(映射出的页表3x4k,自身页目录项4k).4k&lt;&lt;4m.</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>多级页表保证了变相连续性,查找速度快.又保证了内存占用小.</strong></p><p>每增加一级页表也增加了访问时间.用时间改变了占用大小.多级页表增加了访存的次数，尤其是64位系统.如何降低时间呢?</p><h3 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h3><p>TLB是一组相联快速存储器,是寄存器.(CPU中)</p><p><img src="https://i.loli.net/2018/11/19/5bf2ce38e59bc.jpg" alt></p><p>记住最近的页号比对,现在TLB中查询,没有再前往多级页表查询.</p><p>二者相结合,保证页表连续,查找迅速,减少了浪费.经常使用的放在快表中查询.</p><p>实现了空间与时间的优良性.</p><h3 id="TLB的得以发挥的原因"><a href="#TLB的得以发挥的原因" class="headerlink" title="TLB的得以发挥的原因"></a>TLB的得以发挥的原因</h3><p>TLB命中时效率会很高，未命中时效率降低</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/11/19/5bf2cf20c3d72.jpg" alt></p><h4 id="如何提高TLB的命中率"><a href="#如何提高TLB的命中率" class="headerlink" title="如何提高TLB的命中率."></a>如何提高TLB的命中率.</h4><ol><li>越大越好,TLB很贵 通常大概有[64,1024].(折中)</li><li>合理的替换算法.</li></ol><h4 id="为什么在64-1024之间呢"><a href="#为什么在64-1024之间呢" class="headerlink" title="为什么在64-1024之间呢."></a>为什么在64-1024之间呢.</h4><ol><li><p>程序的地址访问存在局部性</p><p><img src="https://i.loli.net/2018/11/19/5bf2cfc136f21.jpg" alt></p><p>在某处会出现较多的访问. </p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>TLB弥补多级页表访问太慢,</p><p>多级页表空间高效,访问较迅速</p><p>形成了在空间上高效,时间上快速的分页机制.</p></li></ol></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="操作系统" scheme="http://xwdidi.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://xwdidi.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="汇编" scheme="http://xwdidi.com/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="内存" scheme="http://xwdidi.com/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>DuiLib环境搭建</title>
    <link href="http://xwdidi.com/2018/11/05/2018-11-05-DuiLib%E6%90%AD%E5%BB%BA/"/>
    <id>http://xwdidi.com/2018/11/05/2018-11-05-DuiLib搭建/</id>
    <published>2018-11-04T16:00:00.000Z</published>
    <updated>2019-04-06T13:59:35.340Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天弄了一天环境,终于编译成功了.如果这篇文章有幸被看到,希望能帮助你少走弯路.</p><ol><li>克隆DuiLib库<code>git clone https://github.com/duilib/duilib.git</code>,duilib中有个大写的DuiLib文件夹,这是我们需要编译的库.</li><li>在VS2015中,创建示例程序是从win32-&gt;win32项目创建的.</li><li>参考DuiLib的<a href="https://github.com/duilib/duilib/wiki/%E6%AD%A3%E7%A1%AE%E7%BC%96%E8%AF%91-Duilib-%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">wiki</a>,比较重要的是lib的引用:附加依赖项,附加包含目录,附加库目录.</li><li>如果采用的是文件的xml格式的话,一定要将xml与exe同一父目录下,不然会出现编译成功,却DuiLib加载资源失败的提示哦.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Duilib" scheme="http://xwdidi.com/categories/Duilib/"/>
    
    
      <category term="Windows编程" scheme="http://xwdidi.com/tags/Windows%E7%BC%96%E7%A8%8B/"/>
    
      <category term="DuiLib" scheme="http://xwdidi.com/tags/DuiLib/"/>
    
      <category term="界面" scheme="http://xwdidi.com/tags/%E7%95%8C%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>(转载)为何建议使用UTF-8</title>
    <link href="http://xwdidi.com/2018/11/03/2018-11-03-(%E8%BD%AC%E8%BD%BD)UTF-8%E5%BF%83%E5%BE%97/"/>
    <id>http://xwdidi.com/2018/11/03/2018-11-03-(转载)UTF-8心得/</id>
    <published>2018-11-02T16:00:00.000Z</published>
    <updated>2019-04-06T14:00:58.819Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://utf8everywhere.org/zh-cn#myth.strlen.correctness" target="_blank" rel="noopener">http://utf8everywhere.org/zh-cn#myth.strlen.correctness</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="转载" scheme="http://xwdidi.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="字符集" scheme="http://xwdidi.com/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
    
      <category term="UTF-8" scheme="http://xwdidi.com/tags/UTF-8/"/>
    
      <category term="Unicode" scheme="http://xwdidi.com/tags/Unicode/"/>
    
  </entry>
  
  <entry>
    <title>孙鑫MFC第五节  文本编程</title>
    <link href="http://xwdidi.com/2018/10/31/2018-10-31-%E5%AD%99%E9%91%ABMFC%E7%AC%AC%E4%BA%94%E8%8A%82/"/>
    <id>http://xwdidi.com/2018/10/31/2018-10-31-孙鑫MFC第五节/</id>
    <published>2018-10-30T16:00:00.000Z</published>
    <updated>2019-04-06T13:51:21.151Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="文本编程"><a href="#文本编程" class="headerlink" title="文本编程"></a>文本编程</h2><p>字处理程序,</p><p>记事本,notepad++ ,甚至是vc++都算是字处理程序.</p><p>都有光标,被叫做插入符.输入的文字信息,通过插入符添加.</p><h3 id="1-创建插入符"><a href="#1-创建插入符" class="headerlink" title="1. 创建插入符"></a>1. 创建插入符</h3><p>利用函数创建插入符,void CreateSolidCaret(int nWidth,int nHeight);插入符的宽度与高度.如果为0,被设置为系统定义的系统默认的窗口边界的宽度与高度.默认是隐藏的,需要调用<code>ShowCaret()</code>函数显示.</p><p>添加<code>WM_CREATE</code>消息处理,会自动增加OnCreate()函数(oncreate()不产生窗口，只是在窗口显示前设置窗口的属性如风格、位置等).而插入符大小应该根据字体改变.通过<code>GetTextMetrics()(HDC hdc,LPTEXTMETRIC,lptm);</code>获得字体信息, 将结构体的指针填入里面,获得信息.</p><h4 id="结构体解析"><a href="#结构体解析" class="headerlink" title="结构体解析"></a>结构体解析</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagTEXTMETRIC</span> &#123;</span></span><br><span class="line">  LONG tmHeight; <span class="comment">//高度,插入符与之相同</span></span><br><span class="line">    </span><br><span class="line">  LONG tmAscent; <span class="comment">//升序,图一</span></span><br><span class="line">    </span><br><span class="line">  LONG tmDescent; <span class="comment">//降序, </span></span><br><span class="line">    </span><br><span class="line">  LONG tmInternalLeading; </span><br><span class="line">  LONG tmExternalLeading; </span><br><span class="line">  LONG tmAveCharWidth; <span class="comment">//平均宽度值,</span></span><br><span class="line">    </span><br><span class="line">  LONG tmMaxCharWidth; <span class="comment">//最大字符宽度.</span></span><br><span class="line">    </span><br><span class="line">  LONG tmWeight;</span><br><span class="line">  LONG tmOverhang; </span><br><span class="line">  LONG tmDigitizedAspectX; </span><br><span class="line">  LONG tmDigitizedAspectY; </span><br><span class="line">  <span class="keyword">char</span> tmFirstChar; </span><br><span class="line">  <span class="keyword">char</span> tmLastChar; </span><br><span class="line">  <span class="keyword">char</span> tmDefaultChar; </span><br><span class="line">  <span class="keyword">char</span> tmBreakChar; </span><br><span class="line">  BYTE tmItalic; </span><br><span class="line">  BYTE tmUnderlined; </span><br><span class="line">  BYTE tmStruckOut; </span><br><span class="line">  BYTE tmPitchAndFamily; </span><br><span class="line">  BYTE tmCharSet; </span><br><span class="line">&#125; TEXTMETRIC;</span><br></pre></td></tr></table></figure><p>图一:<img src="https://i.loli.net/2018/11/03/5bddad46ec47a.jpg" alt></p><p> 获得信息,然后使用它,</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> CTextView::OnCreate(LPCREATESTRUCT lpCreateStruct)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (CView::OnCreate(lpCreateStruct) == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span>  在此添加您专用的创建代码</span></span><br><span class="line">    </span><br><span class="line"><span class="function">CClientDC <span class="title">dc</span><span class="params">(<span class="keyword">this</span>)</span></span>;<span class="comment">//父类存在GetDC()函数,使用this调用.</span></span><br><span class="line">    </span><br><span class="line">TEXTMETRIC tm;</span><br><span class="line">dc.GetTextMetrics(&amp;tm);  <span class="comment">//已经获得</span></span><br><span class="line"></span><br><span class="line">CreateSolidCaret(tm.tmAveCharWidth / <span class="number">8</span>, tm.tmHeight);<span class="comment">//除以8,宽度较为合适</span></span><br><span class="line">    </span><br><span class="line">ShowCaret();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-创建图形插入符"><a href="#2-创建图形插入符" class="headerlink" title="2. 创建图形插入符."></a>2. 创建图形插入符.</h4><p>创建前构造对象<code>CBitmap bitmap</code>,并使用<code>LoadBitmap</code>初始化,<code>CreateCaret(CBitmap * pBitmap)</code> 创建.不过bitma p应该为成员变量.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextView</span> :</span> <span class="keyword">public</span> CView</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">CBitmap bitmap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> CTextView::OnCreate(LPCREATESTRUCT lpCreateStruct)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (CView::OnCreate(lpCreateStruct) == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span>  在此添加您专用的创建代码</span></span><br><span class="line">    </span><br><span class="line"><span class="function">CClientDC <span class="title">dc</span><span class="params">(<span class="keyword">this</span>)</span></span>;<span class="comment">//父类存在GetDC()函数,使用this调用.</span></span><br><span class="line">    </span><br><span class="line">TEXTMETRIC tm;</span><br><span class="line">dc.GetTextMetrics(&amp;tm);  <span class="comment">//已经获得</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//CreateSolidCaret(tm.tmAveCharWidth / 8, tm.tmHeight);//除以8,宽度较为合适</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//CBitmap bitmap;//局部对象,执行完OnCreate()会被析构.所以放到CTextView成员变量中.</span></span><br><span class="line">    </span><br><span class="line">bitmap.LoadBitmapW(IDB_BITMAP3);</span><br><span class="line">CreateCaret(&amp;bitmap);</span><br><span class="line">ShowCaret();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-窗口输出文字"><a href="#3-窗口输出文字" class="headerlink" title="3. 窗口输出文字"></a>3. 窗口输出文字</h3><p>可以使用<code>TextOut()</code>显示文字,但是进行重绘的时候会被擦除掉,我们要保留文字的话,在重绘的时候要重新输出文字.发生重绘的时候会调用函数<code>OnDraw()</code>,该函数会传入<code>CDC</code>指针(CDC已经封装好较多的函数),直接去使用CDC的函数.</p><h4 id="CString类"><a href="#CString类" class="headerlink" title="CString类"></a>CString类</h4><p>字符的大小匹配分配内存都有本身封装好的完成.使用CString对象,字符,字符指针等构造CString.</p><p><code>LoadString()</code>装载ID标识的资源到现存的CString中.先通过资源视图<code>String Table</code>里创建新的字符号,然后加载.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CTextView::OnDraw(CDC* pDC)<span class="comment">//发生重绘的时候会调用该函数</span></span><br><span class="line">    </span><br><span class="line">&#123;</span><br><span class="line">CTextDoc* pDoc = GetDocument();</span><br><span class="line">ASSERT_VALID(pDoc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pDoc)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此处为本机数据添加绘制代码</span></span><br><span class="line"><span class="comment">//CString str("see me");</span></span><br><span class="line">    </span><br><span class="line">CString str;</span><br><span class="line">str = <span class="string">L"see me"</span>;</span><br><span class="line">pDC-&gt;TextOutW(<span class="number">50</span>, <span class="number">50</span>, str);  </span><br><span class="line"></span><br><span class="line">str.LoadStringW(<span class="number">61446</span>);<span class="comment">//新建的ID号</span></span><br><span class="line">    </span><br><span class="line">pDC-&gt;TextOutW(<span class="number">0</span>, <span class="number">200</span>, str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-创建路进程"><a href="#4-创建路进程" class="headerlink" title="4. 创建路进程"></a>4. 创建路进程</h3><p><code>CDC::BeginPath()</code>在路径中打开以后，应用程序可以开始调用绘制功能的GDI定义该点集在路径。 应用程序可以通过调用 <code>EndPath</code>成员函数关闭一个打开的路径括号。 当应用程序调用 <code>BeginPath</code>时，将丢弃所有以前的路径。</p><p>文本显示宽度需要有各种条件得到,但可以通过<code>CDC::GetTextExtent</code>得到,返回<code>CSize</code>对象.CSize来自SIZE结构体.<code>Size</code>中有<code>cx  cy</code>表示高宽.也能通过字符串获取在屏幕中的高度与宽度.</p><p>当第21,23行被注释掉时,会出现默认填充的黑色矩形框.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> CTextView::OnDraw(CDC* pDC)<span class="comment">//发生重绘的时候会调用该函数</span></span><br><span class="line">    </span><br><span class="line">&#123;</span><br><span class="line">CTextDoc* pDoc = GetDocument();</span><br><span class="line">ASSERT_VALID(pDoc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pDoc)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此处为本机数据添加绘制代码</span></span><br><span class="line"><span class="comment">//CString str("see me");</span></span><br><span class="line">    </span><br><span class="line">CString str;</span><br><span class="line">str = <span class="string">L"see me"</span>;</span><br><span class="line">pDC-&gt;TextOutW(<span class="number">50</span>, <span class="number">50</span>, str);</span><br><span class="line"></span><br><span class="line">CSize sz = pDC-&gt;GetTextExtent(str);<span class="comment">//获得高宽.</span></span><br><span class="line"></span><br><span class="line">str.LoadStringW(<span class="number">61446</span>);<span class="comment">//新建的ID号</span></span><br><span class="line">    </span><br><span class="line">pDC-&gt;TextOutW(<span class="number">0</span>, <span class="number">200</span>, str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//pDC-&gt;BeginPath();//确定文本显示大小.</span></span><br><span class="line">    </span><br><span class="line">pDC-&gt;Rectangle(<span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span> + sz.cx, <span class="number">50</span> + sz.cy);</span><br><span class="line"><span class="comment">//pDC-&gt;EndPath();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="探究路进程的作用"><a href="#探究路进程的作用" class="headerlink" title="探究路进程的作用."></a>探究路进程的作用.</h4><p>画黑色线条,</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i += <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">pDC-&gt;MoveTo(<span class="number">0</span>, i);</span><br><span class="line">pDC-&gt;LineTo(<span class="number">300</span>, i);</span><br><span class="line">pDC-&gt;MoveTo(i, <span class="number">0</span>);</span><br><span class="line">pDC-&gt;LineTo(i, <span class="number">300</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src="https://i.loli.net/2018/11/04/5bdef90a07e16.jpg" alt></p><p>做互操作,使用<code>SelectClipPath</code>函数.选择当前路径作为一个剪辑区域(绘图区域)的设备上下文，了新的区域与任何现有的剪辑区域通过使用指定的模式。</p><p><img src="https://i.loli.net/2018/11/04/5bdefcaad44f9.jpg" alt>当前选择路径被排除(RGN_DIFF参数).而RGN_AND只在该区域有图.</p><p>不学了!!!垃圾MFC.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="MFC" scheme="http://xwdidi.com/categories/MFC/"/>
    
    
      <category term="MFC" scheme="http://xwdidi.com/tags/MFC/"/>
    
      <category term="Windows编程" scheme="http://xwdidi.com/tags/Windows%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>内存管理   L21 内存分区与分页</title>
    <link href="http://xwdidi.com/2018/10/25/2018-10-25-L21%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E4%B8%8E%E5%88%86%E9%A1%B5/"/>
    <id>http://xwdidi.com/2018/10/25/2018-10-25-L21内存分区与分页/</id>
    <published>2018-10-24T16:00:00.000Z</published>
    <updated>2019-04-06T13:51:03.764Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id><a href="#" class="headerlink" title="#"></a>#</h1><p>操作系统管理CPU,内存,管理磁盘(设备驱动,文件系统),差不多是比较完整的操作系统</p><p>分段和分页是真正形成了操作系统内存管理</p><ol><li>引出内存分区</li><li>讲解内存分区,引出分页</li><li><p>讲解分页</p><p>CPU的取指执行,就是使用的内存的过程,也就是程序跑起来的过程.</p></li></ol><p>程序是分段处理的,不同的段有不同的作用与特点,执行不同的功能.</p><p>如何使用内存呢,<br>​    将程序放入内存空闲处,若存在指令<code>jmp 40</code>,放入到内存3000处,就是内存被占用. 再将数据段的信息放入到内存中.通过取值执行,执行到<code>jmp 40</code>时,根据LDT表中记录的首地址进行地址翻译,(运行时的重定位);通过LDTR寄存器指向LDT表的起始地址,然后根据<code>jmp 40</code>中的段地址寄存器寻找到对应的LDT表,然后得到了物理地址.这已经开始执行程序了.</p><p>那么其他进程怎么执行,那就创建第二个进程相关的LDT表,LDT表示放到了进程的PCB中.根据LDT进行执行时的重定位.进行合适的跳转.切换PCB后,LDT也当然会切换.LDTR也会修改,指向另一个新表.<code>switch_to()</code>执行后的<code>jmp 40</code>也会发生改变.进程的切换,LDT也会切换,在很早之前所说的映射表其实就是LDT.</p><ol><li><p>程序分段(编译阶段)</p></li><li><p>内存中寻找空间分区</p><p> 几个算法+数据结构</p></li><li><p>读入程序(文件系统,磁盘管理)</p><p>设备驱动</p></li><li><p>初始化LDT表和PCB.</p><p>建立映射表,与PCB关联</p></li></ol><h2 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h2><ol><li>如何去寻找空闲的内存区域.</li></ol><p>​    这样就可以将程序的各个段载入到相应的内存分区中了.</p><ol start="2"><li><p>如何分割内存呢</p><ul><li><p>固定分区</p><p>等分，操作系统初始化时将内存等分成k个分区</p><p>但孩子有大有小，段也有大有小，需求不一定</p></li><li><p>可变分区的管理.</p><p>需要多少,在空闲区域分配多少</p><p><img src="https://i.loli.net/2018/10/25/5bd1d40d4c3b7.jpg" alt></p><ol><li>空闲区域为250k-500k,有个请求为<code>reqSize = 100K</code>,通过数据结构记录内存区域划分, 空闲分区表起始地址改变为350k,长度为150k,已分配分区表增加一行相应的信息就可以了.但不一定只是使用,也会有释放.如段2不再需要,释放内存.在空闲分区表添加相应一行就行了.已分配分区表删除seg2.</li></ol><p><img src="https://i.loli.net/2018/10/25/5bd1d6f3dc272.jpg" alt></p><p>​    </p><ol start="2"><li><p>再次申请</p><p>又一个段提出内存请求:<code>reqSize = 40k</code>这时候两个空闲区段,如何判断选哪一个更合适呢. </p></li></ol><p>操作系统一般会选择折中的算法,</p><p>首先适配:(350,150),查询速度快,在第一位,O(1)算法</p><p>最佳适配:(200,50),空闲区域越来越小,容易碎片化</p><p>最差适配:(350,150),可以得到比较均匀的内存分配区域,无法得到过大的内存区域,O(n)算法</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结,"></a>总结,</h4><p>操作系统为了将内存使用起来,将会分成多个段.程序放入到空闲区域.</p><ol><li>维护数据结构</li><li>选择合适的算法,加上合适的数据结构,段的结构,在PCB初始化代码添加,就能管理起内存,最小的操作系统就能建立起来.</li></ol></li></ul></li><li><p>现代操作系统也支持分页,为什么,如何去支持分页.</p><p>其实并不使用内存分区,为了让段放到内存中(段会采用虚拟内存进行率先处理),段物理内存实际采用了内存分页进行割断,</p><p>虚拟内存采用最佳适配分区分割,而物理内存采用分页分段的方法.</p></li></ol><h3 id="引入分页：解决内存分区导致的内存效率问题"><a href="#引入分页：解决内存分区导致的内存效率问题" class="headerlink" title="引入分页：解决内存分区导致的内存效率问题"></a>引入分页：解决内存分区导致的内存效率问题</h3><p>内存分区效率不高:分区完,无论使用任何方法总会产生内存碎片,然而采用分页就不会出现.(为什么呢)</p><p>例如:</p><p><code>reqSize = 160k</code>任何一个区域都放不进去,即使是有内存,也放不进去.</p><p><img src="https://i.loli.net/2018/10/27/5bd4314c1c07b.jpg" alt></p><p>如何不浪费这些内存呢.</p><ol><li><p>将空闲分区合并,需要移动1个段,<strong>内存紧缩</strong>:需要花大量时间,而且时间过长容易被识别为死机状态.</p></li><li><p>将请求打散,160k分为两个小段.</p><p>针对每个段内存请求，系统一页一页的分配给给这个段.(向上取整).好处在于对于使用不完的页,减少内存的浪费.最多浪费1页,并且不用内存紧缩.之前在<code>mem_init()</code>中,以每页4kb大小进行初始化.</p><p>用户希望分段,程序由段组成,物理内存分页,段页合在一起.建立基本的操作系统.</p><p>连续-&gt;离散.</p><p><code>jmp 40</code>如何跳转到相应的页数上,1页长度为100,40是第0页,所以会跳转到第五个页框<code>540</code>.</p><p><img src="https://i.loli.net/2018/10/27/5bd44527717fb.jpg" alt></p><p>页0放在页框5中，页0中的地址就需要重定位</p><p>那么如何计算,根据之前段的计算,我们将采用页表.</p><p><img src="https://i.loli.net/2018/10/27/5bd449feada4b.jpg" alt></p><p>段表的寄存器为LDTR,页表的寄存器为CR3.进程切换时,cr3也会跟着切换.</p><p>40/100余40,那么就是页0,便宜40.</p><p>4k = 2^12. 2240/4k.右移12位,右移3个数.只剩下2,所以得到<code>0x02|0x240</code>,(由内存管理单元MMU计算得到).</p><p>MMU如何运行的了,读取到指令后,将地址右移12位,根据页表指针(PCB中)在表中寻找.页号为2,页框好为3,然后的到物理地址0x3240.</p><p>内存的段是很多页组成的,页表指针也和PCB关联,执行这条指令需要去查询页表,进行重定位.</p><blockquote><p>在基本的分页概念中，我们把程序分成<strong>等长</strong>的小块。这些小块叫做“<strong>页（Page）</strong>”，同样内存也被我们分成了和页面同样大小的”<strong>页框（Frame）“，</strong>一个页可以装到一个页框里。在执行程序的时候我们根据一个页表去查找某个页面在内存的某个页框中，由此完成了逻辑到物理的映射。</p><p><a href="https://www.zhihu.com/question/50796850" target="_blank" rel="noopener">https://www.zhihu.com/question/50796850</a></p></blockquote></li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>   一个程序是由多个段组成,每一个段不是直接放在内存中,直接放到内存中的话容易引起内存的浪费,造成大量碎片.将段打散成多个页,每个段要放在页中.为了将来实现重定位,找到程序执行的地址,就要建立页表.</p><p>开启分页前,内核所有地址都变成了虚拟地址,所有的地址都要通过 MMU 映射到物理地址再访问内存</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="操作系统" scheme="http://xwdidi.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://xwdidi.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="汇编" scheme="http://xwdidi.com/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="内存" scheme="http://xwdidi.com/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>内存管理     L20 内存使用与分段</title>
    <link href="http://xwdidi.com/2018/10/23/2018-10-23-L20%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%88%86%E6%AE%B5/"/>
    <id>http://xwdidi.com/2018/10/23/2018-10-23-L20内存使用与分段/</id>
    <published>2018-10-22T16:00:00.000Z</published>
    <updated>2019-04-06T13:50:40.930Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h2><p>​    如何管理CPU,多进程图像切换or同步等,</p><p>操作系统如何管理内存?</p><h3 id="内存如何使用"><a href="#内存如何使用" class="headerlink" title="内存如何使用"></a>内存如何使用</h3><ol><li><p>计算机如何工作</p><p>取指-执行-取指-执行-…….</p><p>是从内存中取出,</p><p>因为使用了内存,才能取出.</p><p><strong>内存使用</strong>:将程序放到内存中,PC指向开始地址</p></li></ol><ol start="2"><li><p>如何让程序加载到程序中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">_entry://入口地址</span><br><span class="line"></span><br><span class="line">call _main</span><br><span class="line">call _exit</span><br><span class="line">_main:</span><br><span class="line">...</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_entry://入口地址</span><br><span class="line"></span><br><span class="line">call 40</span><br><span class="line">call xx</span><br><span class="line">main://偏移是40</span><br></pre></td></tr></table></figure><p>通过entry跳回到从开头偏移40的main函数,</p><hr><p>编译完放到磁盘中,通过读入磁盘放进内存中.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">内存地址物理内存</span><br><span class="line">   ...</span><br><span class="line">40 _main:mov [300],0</span><br><span class="line">...</span><br><span class="line">   call xx</span><br><span class="line"> 0 call 40</span><br></pre></td></tr></table></figure><p>call 40,跳回到40执行通过地址总线发送40,物理地址40的位置就是main函数的第一条命令(也就是入口地址).</p><p>IP = 0,<code>call 40</code>就跳入到了main函数,</p><p>缺点在于,程序起始位置必须放到固定物理内存0地址处.PC指针等于0,才能正确执行.0地址处不一定存在空闲,而且这样的话也容易与新程序冲突.而且0地址开始处放入的是操作系统程序.</p><p><strong>所以</strong>应该把程序放到空闲内存处,如果程序其实地址为1000,那么<code>call 40</code>不应该跳入到40地址处.应该跳入到1040地址处.</p><p>这时候应该<strong>重定位</strong>(PE文件相关知识):修改程序中的地址(是相对地址)(逻辑地址).在程序放入到内存中,将40修改成1040.<code>300</code>必成1300.</p><ul><li><p>什么时候完成重定位?</p><p><u>编译时</u>,不现实,在PC中,需要知道执行时的内存空闲位置几乎不可能知道.然而在一些卫星,嵌入式中(静态系统中),可以实现.不够灵活.编译时重定位的程序只能放在内存固定位置,效率高.</p><p><u>载入时</u>,更容易实现,更灵活,只需要将所有地址都加上基地址的值就可以了.更加灵活.载入时重定位的程序一旦载入内存就不能动了,速度较慢.</p><ul><li><p>程序载入后还需要移动</p><p>交换(swap):内存资源紧张,磁盘较大,磁盘中的虚拟内存和内存进行数据交换</p><p><img src="https://i.loli.net/2018/10/23/5bcf2b03ee289.jpg" alt></p></li></ul><p>所以是<strong>执行每条指令时</strong>进行<strong>重定位</strong>,每执行一条指令都要地址翻译.基地址+偏移地址= 物理地址.(地址翻译)</p><ul><li><p>如何去存放基地址呢? 如何去更换基地址?</p><p>进程中发生的这些变化的依据<u>基地址</u>都放在进程的PCB中,基地址会随着加载内存地址的改变而改变.</p><p>执行指令时第一步先从PCB中取出这个基地址.</p></li></ul></li></ul></li></ol><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>   编译好程序 </p><p>   在内存中寻找空闲内存,创建进程,PCB</p><p>   将空闲地址放入到PCB中,</p><p>   基地址放在基地址寄存器中.switch_to()时,也切换PCB.</p><pre><code>可执行程序找到空闲内存,拿出基地址放入PCB中,然后放入到这段空闲内存中,上下文切换时,PCB的基地址等于基地址寄存器的值,每次地址执行时,都要进行地址翻译,寻找到物理地址,执行.</code></pre><ol><li>假设执行<code>mov ax,[100]</code></li></ol><ul><li>PCB中基地址赋值给寄存器,从寄存器取出地址后,要访问100这个地址,通过地址翻译(基地址+100),找到实际的地址.得到该处数据.</li></ul><ol start="2"><li>执行switch</li></ol><ul><li><p>然后将进程2的PCB中的基地址写入到基地址寄存器中.2000变为1000.再执行<code>mov ax,[100]</code>,就去访问了1100.</p><p><img src="https://i.loli.net/2018/10/23/5bcf335525a5c.jpg" alt></p></li></ul><h3 id="引入分段"><a href="#引入分段" class="headerlink" title="引入分段"></a>引入分段</h3><p>是将整个程序载入到内存中吗?</p><p>程序是由若干段组成的,堆(.heap),栈(.heap),代码区,初始化数据段,未初始化数据段.</p><p>符合用户观点,独立考虑每个段的特点,用途(分治)可以通过&lt;段号.段内偏移&gt;访问.例如<code>mov [es:bx],ax</code>. 如果所有程序全放在一起,是无法分小段载入.</p><h4 id="不是将整个程序，是将各段分别放入内存"><a href="#不是将整个程序，是将各段分别放入内存" class="headerlink" title="不是将整个程序，是将各段分别放入内存"></a>不是将整个程序，是将各段分别放入内存</h4><p>​    如果不是分段存储,而是整段放入的话.栈是会持续增长的,如果存储空间不够,需要申请新的较大内存空间,然后再将原数据拷贝到那,此时会造成二者空间皆不可用造成内存的浪费.</p><p>​    如果分段放入,只需要移动单一的栈存储空间,提高了内存的使用率,也符合了人们的使用习惯</p><p>指令: <code>&lt;段号.段内偏移&gt;</code></p><p>当然这也会造成各段基地址不一样, 所以需要通过查询<strong>段表</strong>来记录每个段相应的基地 址. </p><p>比如之前<code>jmp 0, 8</code>通过0去查询gdt表获得基地址CS&lt;&lt;4+ip 采用保护模式寻址，cs=8用来查GDT表，表内偏移为0;然而GDT的表是处理操作系统的.每个进程有自己的段表<strong>LDT</strong>.</p><p>所以最后采用GDT+LDT的寻址方式,获得自己的基地址处.每次进行地址翻译时,根据LDT表中的段地址进行查询.</p><p><img src="https://i.loli.net/2018/10/24/5bd06a892dcdb.jpg" alt></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一个程序多个段,然后每个段在内存中找到内存空闲处,将基地址放入到LDT表中,LDT查询表是由多个LDT表线性组成,</p><p>初始化LDT表后,</p><p>赋值给PCB,</p><p>设好初始地址,</p><p>PC指针取值执行,每次执行时,进行查表查找基地址,然后找到物理地址.</p><p>就能进行相关操作了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="操作系统" scheme="http://xwdidi.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://xwdidi.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="汇编" scheme="http://xwdidi.com/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="内存" scheme="http://xwdidi.com/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>进程运行轨迹的跟踪与统计</title>
    <link href="http://xwdidi.com/2018/10/19/2018-10-19-%E5%AE%9E%E9%AA%8C-%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/"/>
    <id>http://xwdidi.com/2018/10/19/2018-10-19-实验-进程运行轨迹的跟踪与统计/</id>
    <published>2018-10-18T16:00:00.000Z</published>
    <updated>2019-04-06T13:50:33.151Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.shiyanlou.com/courses/115/labs/570/document" target="_blank" rel="noopener">实验指导</a></p><p><a href="http://www.oldlinux.org/download/clk011c-3.0.pdf" target="_blank" rel="noopener">linux内核完全注释</a></p><p>今天简单跟着实验楼的操作系统原理与实践,第四个进程轨迹的跟踪.</p><p>实际上难点的在于是如何去判断切换点的位置所在,然后进行输出就行醒了,这对于源码的理解变得更加深层,当然这可以通过读书去了解 读&lt;&lt;linux内核完全注释&gt;&gt;,经过代码注释能很好理解相关内核函数的运行.</p><p>这个实验自己做的话,bochs系统没有启动成功虚拟机里,实验楼环境里也是,</p><p>最后做出来了,原因是函数中加载文件描述符的一行没有写进去,.,</p><p>通过修改main.c 启动进程,修改文件加载符的位置,和打开文件流,进行输入输出. 通过阅读代码获知进程改变时的位置在那进行添加记录代码,</p><p>试一次较为比较有深度的试验探索了</p><blockquote><p>总的来说，Linux 0.11支持四种进程状态的转移：就绪到运行、运行到就绪、运行到睡眠和睡眠到就绪，此外还有新建和退出两种情况。其中就绪与运行间的状态转移是通过schedule()（它亦是调度算法所在）完成的；运行到睡眠依靠的是sleep_on()和interruptible_sleep_on()，还有进程主动睡觉的系统调用sys_pause()和sys_waitpid()；睡眠到就绪的转移依靠的是wake_up()。所以只要在这些函数的适当位置插入适当的处理语句就能完成进程运行轨迹的全面跟踪了。</p></blockquote><p>睡眠其实就是堵塞状态.</p><p>希望这个实验我能去更加好的理解源码.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="操作系统实验" scheme="http://xwdidi.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="操作系统" scheme="http://xwdidi.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="内核修改" scheme="http://xwdidi.com/tags/%E5%86%85%E6%A0%B8%E4%BF%AE%E6%94%B9/"/>
    
      <category term="实验" scheme="http://xwdidi.com/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
</feed>
